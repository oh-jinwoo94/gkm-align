#include "header.h"


int main(int argc, char *argv[]) {

	
    if(argc != 3){
        cout << "Usage <0> <input binary matrix file>  <ofname>" <<endl;
        exit(1);
    }

    string ifile_name = argv[1];
    string ofname = argv[2];

    Matrix M = Matrix(ifile_name);
    M.save_matrix_tsv(ofname);

    return 0;
}


#include "header.h"


// similar functions defined in header, but this version below allows more flexibilities. Defined at the bottom
float compute_matrix(string s1, string s2, int l, vector<unsigned long long int>&  shared_gkm);
float compute_matrix_norm(string s1, string s2, int l, vector<unsigned long long int>& shared_gkm);
unsigned long long int nchoosek(int n, int k);

int main(int argc, char *argv[]) {

	
    if(argc != 5){
        cout << "Usage <0> <ifile name>  <l> <k> <ofname>" <<endl;
        exit(1);
    }

    string ifile_name = argv[1];
    int l = atoi(argv[2]);
    int k = atoi(argv[3]);
    string ofname = argv[4];


    // used for fast gkm sim computation
    vector<unsigned long long int> shared_gkm;
    for (int m = 0; m < l + 1; m++) {
        if ((l - m) >= k) {
            shared_gkm.push_back(nchoosek(l - m, k));
        } else {
            shared_gkm.push_back(0);
        }
    }


    ifstream ifile(ifile_name);

    ofstream ofile;
    if(ofname == "-1"){
	    cout << "output file name must be specified using -o flag" << endl;
	    exit(1);
    }
    ofile.open(ofname);

    cout << "using .. " << endl;
    cout << "l = " << l <<endl;
    cout << "k = " << k << endl;
    string seq1; string seq2;
    string trash;
    string line; string oline;
    while (!ifile.eof()){
        getline(ifile, line);
        if(line.length() == 0){ continue;}
        istringstream ss(line);
        ss >> seq1 >> seq2;
        transform(seq1.begin(), seq1.end(), seq1.begin(), ::toupper);
	transform(seq2.begin(), seq2.end(), seq2.begin(), ::toupper);

        float gkmsim = compute_matrix_norm(seq1, seq2, l, shared_gkm);
	ofile << gkmsim << endl;
    }
    ofile.close();
    ifile.close();
    return 0;
}



float compute_matrix(string s1, string s2, int l, vector<unsigned long long int>&  shared_gkm){
    float tot = 0;
    unsigned int mismatch;

    string::iterator it1 = s1.begin();
    string::iterator it2 = s2.begin();

    for(int i = 0; i <= (int)s1.length()-l; i++){
        for(int j = 0; j <= (int)s2.length()-l; j++){
           mismatch = 0;
           for(int q = 0; q<l; q++){
               char a = *(it1+(i+q));
               char b = *(it2+(j+q));
               mismatch += (a!=b);
           }
           tot += shared_gkm[mismatch];

        }
     }
    return tot;
}




float compute_matrix_norm(string s1, string s2, int l, vector<unsigned long long int>& shared_gkm){
    if((int)s1.length() < l || (int)s2.length() < l){
        return 0;
    }else{
        float k11 = compute_matrix(s1, s1, l, shared_gkm);
        float k22 = compute_matrix(s2, s2, l, shared_gkm);
        float k12 = compute_matrix(s1, s2, l, shared_gkm);
        return k12/(sqrt(k11)*sqrt(k22));
    }
}

unsigned long long int nchoosek(int n, int k) {
    unsigned long long int num = 1;
    unsigned long long int den = 1;

    for (int i = k + 1; i <= n; i++) {
        num = num * i;
    }

    for (int i = 1; i <= (n - k); i++) {
        den = den * i;
    }
    return num / den;
}

// some simple and useful functions 


#include "header.h"
const vector<char> ATGC = {'A', 'T', 'G', 'C'};
const unordered_map<char,char> comp = {{'A', 'T'}, {'T', 'A'}, {'G', 'C'}, {'C', 'G'}};

void help(){
	    cout << endl <<endl <<endl;;
            cout << " ========================================================================================================" <<endl;
            cout << "| gkm-align: gapped-kmer based whole-genome alignment software for mapping conserved distal enhancers     |" <<endl;
            cout << "|                                                                                                         |" << endl;
            cout << "| version: v.1.0                                                                                          |" << endl;
            cout << "|                                                                                                         |" << endl;
            cout << "| For more details, please refer to the github README and the gkm-Align paper.                            |" <<endl;
	    cout << "| - github: https://github.com/oh-jinwoo94/gkm-align                                                      |" << endl;
	    cout << "| - paper : https://www.biorxiv.org/content/10.1101/2023.10.06.561128v1                                   |" << endl;
            cout << " ========================================================================================================\n" << endl;
            cout << "Usage: " <<endl;
            cout << "                  (1) for genome alignment (-t 1):" << endl;
	    cout << "                          ./gkm_align -t 1 -d <genomes> -g <genome_background_models.txt> <input: loci.2align>\n" << endl;
            cout << "                  (2) for enhancer mapping (-t 2):" << endl;
	    cout << "                          ./gkm_align -t 2 -c <alignment_output.coord> -m <input: enhancers.bed> \n" << endl;


            cout << "Software arguments & options" << endl;
            cout << "(1) for genome alignment (-t 1): " << endl;
	    cout << "  input argument      [required] 2align containing interspecies syntenic loci to align." << endl;
            cout << "  -d <string>         [required] directory containing hg38/ and mm10/" <<endl;
            cout << "                                 (or other genomes of interest containing .fasta files for each chromosomes)" << endl;
            cout << "  -g <string>         [required] .txt containing file names for a genome background model for each species\n" << endl;
            cout << "  -l <int>            Gapped-kmer width (default: 11; e.g., -TGA-TCAT--)" << endl;
            cout << "  -k <int>            Number of non-gapped positions in the gapped kmers (default: 7; e.g., -TGA-TCAT--)" << endl;
            cout << "                      - must be smaller than or equal to l." << endl;
            cout << "  -w <int>            Width of the sliding windows (default: 300)" << endl;
            cout << "  -s <int>            Sliding step size of the sliding windows (default: 20)" << endl;
            cout << "                      - w must be divisiable by s (e.g., w = 300 and s = 20)" << endl;
            cout << "  -i <float>          Indel penalty for insertion/deletion (default: 0; scale: Z-score)" << endl;
            cout << "  -p <int>            Number of parallel threads for multithreaded alignment. (default: 1)" <<endl;
	    cout << "  -W <float,string>   Use this option for cell-specific genome-alignment weighted by gkm-SVM enhancer models." << endl;
            cout << "                      float : enhancer model weight ('c': 0-1)" << endl;
            cout << "                      string: .txt containing file names of the enhancer models" <<endl;  
	    cout << "  -G                  Save gkm-similarity matrices to a local directory (default: no save; -o dir/)" << endl;
	    cout << "  -O                  By default, gkm-Align uses relevant gkm-matrices in a directory specified by the -o option." << endl;
	    cout << "                      Provide -O to ignore existing gkm-matrices\n" << endl;

            cout << "(2) for enhancer mapping (-t 2): " << endl;
            cout << "  input argument      [required] .bed containing query enhancers to map." << endl;
            cout << "  -c <string>         [required] .coord output file from -t 1 genome alignment" << endl;
            cout << "  -q <string>         [required] query genome (e.g., hg38 for mapping human enhancers to the mouse genome) \n" << endl;
            cout << "  -m or -u            [required] either -m or -u must be provided. " << endl;
	    cout << "                                 -m: allows mapping enhancers to multiple elements." <<endl;
	    cout << "                                 -u: restrict to unique mapping. \n" << endl; 

	    cout << "shared options: " << endl;
	    cout << "   -o                 output directory   (default: current directory)" <<endl;
	    cout << "   -n                 output file prefix (default: input file prefix )" << endl;

}

unsigned long long int nchoosek(int n, int k) {
    unsigned long long int num = 1;
    unsigned long long int den = 1;

    for (int i = k + 1; i <= n; i++) {
        num = num * i;
    }

    for (int i = 1; i <= (n - k); i++) {
        den = den * i;
    }
    return num / den;
}


void check_file(string fname)
{
    ifstream ifile(fname);
    if(ifile.good() == false){
        cout<< "The following file is not available: " << fname <<endl;
        exit(1);
    }
    ifile.close();
}





// extract directory name from file name. 
// returns "" if no dir name
string dirname(string fname){
    int loc = -1;
    for (unsigned int i = 0; i < fname.length(); i++) {
        if (fname[i] == '/') {
            loc = i;
        }
    }

    string dir = fname.substr(0, loc + 1);
    return dir;
}

string basename(string fname){
    int loc = -1;
    for (unsigned int i = 0; i < fname.length(); i++) {
        if (fname[i] == '/') {
            loc = i;
        }
    }

    string base = fname.substr(loc + 1, fname.length() - (loc+1));
    return base;
}




string getexepath(){
  char result[ PATH_MAX ];
  ssize_t count = readlink( "/proc/self/exe", result, PATH_MAX );
  return dirname(string( result, (count > 0) ? count : 0 ));
}


// if unknown character is given (non ATGC), leave as it is. 
string revcomp(string seq) {
    string oseq = "";
    for (char c : seq) {
        auto it = comp.find(c);
        if (it != comp.end()){
            oseq = (it->second) + oseq;
        }else{
            oseq = c + oseq;
        }
    }
    return oseq;
}

// just turn into upper case and replace unknonw characters with random ATGC
string preprocess_seq(string seq) {
    transform(seq.begin(), seq.end(), seq.begin(), ::toupper);
    filter_unknown(seq);
    return seq;
}



// read the entire sequence in the single fasta file
string read_fa(string fname) {
    check_file(fname);
    ifstream fa_file(fname);
    string seq = "";
    string line;
    while (getline(fa_file, line)) {
        seq += line;
    }
    fa_file.close();
    return seq;
}

// read fasta file to extract sequences in the predefined range
// [start, end)
// if start <0, read from beginning of the file. if end > chromosome length, then read to the end 
string read_fa(string fname, int start, int end) {
    check_file(fname);
    ifstream fa_file(fname);
    string seq = "";
    int curr_coord = 0;
    string line;
    bool read_seqs;
    if(start <= 0){
        read_seqs = true;
        start = 0;
    }else{
        read_seqs = false;
    }

    while (getline(fa_file, line)) {
        if (read_seqs == true) {
            if (curr_coord + line.length() > (unsigned int)end) {
                seq += line.substr(0, end - curr_coord);
                break;
            } else {
                seq += line;
            }
        } else if (curr_coord + line.length() > (unsigned int)start) {
            read_seqs = true;
            int s = start - curr_coord;
            seq += line.substr(s, line.length() - s);
        }
        curr_coord += line.length();
    }
    fa_file.close();
    return seq;
}

// assuming all in upper case.
void filter_unknown(string &seq) {
    vector<char>::const_iterator it;
    for (char &c : seq) {
        it = std::find(ATGC.begin(), ATGC.end(), c);
        if (it == ATGC.end()) {
            c = ATGC[rand() % 4];
        }
    }
}



pair<string, string> generate_regions_to_align(string gdir, string build1, string build1_chr, int build1_start, int build1_end,
		                               string build2, string build2_chr, int build2_start, int build2_end,
					       int window, int slide){
    string build1_fname = gdir + build1 + "/" + build1_chr + ".fa";
    string build2_fname = gdir + build2 + "/" + build2_chr + ".fa";

    string seq1 = read_fa(build1_fname, build1_start, build1_end);
    string seq2 = read_fa(build2_fname, build2_start, build2_end);


    seq1 = preprocess_seq(seq1);
    seq2 = preprocess_seq(seq2);


    if ((window % slide) != 0) {
        cout << "window width must be divisible by the slide width" << endl;
        exit(1);
    } // part 1 complete

    if ((seq1.length() - window) % slide != 0) {
        int length_final = window + ((seq1.length() - window) / slide) * slide;
        seq1 = seq1.substr(0, length_final);
    }

    if ((seq2.length() - window) % slide != 0) {
        int length_final = window + ((seq2.length() - window) / slide) * slide;
        seq2 = seq2.substr(0, length_final);
    }

    return make_pair(seq1, seq2);
}

// regular weight file
void load_weights(unordered_map<string, float> &kmer_weights,
                  string fname) {

    check_file(fname);
    kmer_weights.clear();
    ifstream wfile(fname);
    string kmer;
    float weight;
    string line;
    while (getline(wfile, line)) {
        std::istringstream ss(line);
        ss >> kmer >> weight;
        kmer_weights[kmer] = weight;
    }
    wfile.close();
}

tuple<int, float, float, float, float, unsigned int> load_post_weights(unordered_map<string, float> &kmer_weights,
                  string fname) {
        // format:
	// w	300
        // mu_pos  -0.4698601590268965
        // var pos 0.0002796103768422355
       // mu_neg  -0.5784510419876551
        // var_neg 0.0010991364946907067
        // CCCCGATATAC     -0.6253484

    check_file(fname);
    kmer_weights.clear();
    ifstream wfile(fname);
    cout << fname << endl;
    string kmer;
    float weight;
    string line;
    int pred_width; float mu_pos; float var_pos; float mu_neg; float var_neg;
    unsigned int k;
    string trash;
    int i = 0;
    while (getline(wfile, line)) {
	std::istringstream ss(line);
	if(i==0){ss >> trash >> pred_width;}
	if(i == 1){ss >> trash >> mu_pos;}
	else if(i == 2){ss >> trash >> var_pos;}
	else if(i == 3){ss >> trash >> mu_neg;}
	else if(i == 4){ss >> trash >> var_neg;}
	else{
            ss >> kmer >> weight;
            kmer_weights[kmer] = weight;
	    if(i==5){k = kmer.size();}
	}
	i++;
    }
    wfile.close();
    return make_tuple(pred_width, mu_pos, var_pos, mu_neg, var_neg, k);
}


tuple<int, float, float, float, float, unsigned int> load_post_weights_to_matrix(unordered_map<string, vector<float>> &kmer_weight_matrix,
                  string fname) {
//w       300.0
//mu_pos  0.3888576375783236
//var_pos 0.0326371041453618
//mu_neg  0.040440167715889916
//var_neg 0.04457310205165671
//AAAAAAAAAAA     1.5321328531827556


    check_file(fname);
    ifstream wfile(fname);
    cout << fname << endl;
    string kmer;
    float weight;
    string line;
    int pred_width; float mu_pos; float var_pos; float mu_neg; float var_neg; 
    int k;
    string trash;
    int i = 0;
    while (getline(wfile, line)) {
        std::istringstream ss(line);
	if(i==0){ss >> trash >> pred_width;}
        if(i == 1){ss >> trash >> mu_pos;}
        else if(i == 2){ss >> trash >> var_pos;}
        else if(i == 3){ss >> trash >> mu_neg;}
        else if(i == 4){ss >> trash >> var_neg;}
        else{
            ss >> kmer >> weight;
	    if(kmer_weight_matrix.find(kmer) == kmer_weight_matrix.end()){
		kmer_weight_matrix[kmer] = {weight};
	    }else{
                kmer_weight_matrix[kmer].push_back(weight);
	    }
            if(i==5){k = kmer.size();}
        }
        i++;
    }
    wfile.close();
    return make_tuple(pred_width,  mu_pos, var_pos, mu_neg, var_neg, k);
}

// this is for Masker. has both kmer weights and a threshold value. 
// format: 
// * threshold: 0.359557
// # Threshold obtained using using:
// # hg38    chr21   20000000 20100000
// AAAAAAAAAAA     1.6789377
// ATATATATATA     1.5665055
// ACACACACACA     1.208083756
float load_weights_threshold(unordered_map<string, float> &kmer_weights,
                  string fname) {

    check_file(fname);
    kmer_weights.clear();
    ifstream wfile(fname);
    string kmer;
    string tmp;
    float weight;
    float threshold;
    string line;
    int index = 0; 
    while (getline(wfile, line)) {
        std::istringstream ss(line);

        if(index == 0 && (line[0]!='*')){
            cout << "Wrong file format. First line must contain threshold information" << endl;
            exit(0);
        }

        if(line[0] == '*'){
            ss >> tmp >> tmp >> threshold; 
        }else if(line[0] == '#'){
            continue;
        }else{
            std::istringstream ss(line);
            ss >> kmer >> weight;
            kmer_weights[kmer] = weight;
        }
        index++;
    }
    wfile.close();
    return threshold; 
}


// Adds up all kmer weights in the seq. Then divide by the number of kmers. 
float score_seq(const string& seq, const unordered_map<string, float>& kmer_weights, int k) { 
    float sc = 0;
    string subseq;
    int n = 0;
    for (unsigned int i = 0; i < seq.length() - k + 1; i++) {
        subseq = seq.substr(i, k);
        auto iter = kmer_weights.find(subseq);
        if (iter != kmer_weights.end()) { // kmer found
            sc += (*iter).second;
        } else { // not found
            iter = kmer_weights.find(revcomp(subseq));
            if (iter != kmer_weights.end()) { // revcomp(kmer) found
                sc += (*iter).second;
            } else { // Contains unidenfied character (i.e. not ATGC)
                cout << "Unrecognized kmer found: " << subseq << endl;
                cout<< "debugging required." << endl;
                exit(EXIT_FAILURE);
                return 0;
            }
        }
	n++;
    }
    if(n==0){
        cout<<"Length of input sequence must be larger than k"<<endl;
        exit(1);
    }

    return sc / (seq.length() - k + 1);
}
vector<float> score_seq_multigkm(const string& seq, const unordered_map<string, vector<float>>& kmer_weight_matrix, int k) {
    string subseq;
    // # gkm models
    int m = ((kmer_weight_matrix.begin())->second).size();

    vector<float> sc_v(m);
    int n = 0;
    for (unsigned int i = 0; i < seq.length() - k + 1; i++) {
        subseq = seq.substr(i, k);
        auto iter = kmer_weight_matrix.find(subseq);
        if (iter == kmer_weight_matrix.end()) { // if not  found
            iter = kmer_weight_matrix.find(revcomp(subseq));
            if (iter == kmer_weight_matrix.end()) { // even revcomp not found 
                cout << "Unrecognized kmer found: " << subseq << endl;
                cout<< "debugging required." << endl;
                exit(EXIT_FAILURE);
            }
        }
	for(int j = 0; j<m; j++){
		sc_v[j] += (iter->second)[j];
	}
        n++;
    }
    if(n==0){
        cout<<"Length of input sequence must be larger than k"<<endl;
        exit(1);
    }
    for(auto& sc : sc_v){
	sc = sc / (seq.length() - k + 1);
    }
    return sc_v;
}


// normalize gkm-SVM score to vary between 0 and 1
float posterior_transform(float sc, float mu_pos, float var_pos, float mu_neg, float var_neg){
    float sc_p;
        float P_pos = exp(-0.5*(pow(sc-mu_pos, 2))/var_pos + log(0.5) - 0.5*log(2*M_PI*var_pos));
        float P_neg = exp(-0.5*(pow(sc-mu_neg, 2))/var_neg + log(0.5) - 0.5*log(2*M_PI*var_neg));


	// in case of moderately overlapping bimodal distributions, for extremely small or large sc, both p-pos and p-neg can be close to zero. 
	// For well-seperated bimodal distributions, intermediate sc can also give p-pos and p-neg close to zero. 
	// In such cases, return 0/0.05/1
	if(P_pos < 0.001 && P_neg < 0.001){
		if(sc > mu_pos) {return 1;}
		else if(sc < mu_neg) {return 0;}
		else {return 0.5;}
	} else {
        	sc_p = (P_pos / (P_pos + P_neg));

		// keep the function as monotonic as possible without distorting it too much. 
		if(sc > mu_pos && sc_p < 0.5){
			return 1;
		}else if (sc < mu_neg && sc_p > 0.5) {
			return 0;
		}else{
			return sc_p;
		}
	}
}

// Given a sequence S of size L
// output vector v[i] stores prediction score for a window of size pred_width centered around (S[(i*slide_width + window_width) / 2])
vector<float> score_sliding_windows(string seq, int window_width, int slide_width, 
		                    tuple<int, float, float, float, float, unsigned int> post_stat,
				    const unordered_map<string, float>& kmer_weights){

    size_t dim = (seq.size() - window_width)/slide_width + 1;
    vector<float> score_vect(dim);

    int pred_width = get<0>(post_stat);
    float mu_pos = get<1>(post_stat); float var_pos = get<2>(post_stat);
    float mu_neg = get<3>(post_stat); float var_neg = get<4>(post_stat);
    unsigned kmer_size = get<5>(post_stat);

    float sc; float sc_p;
    string subseq;
    for(size_t i = 0; i < dim; i++){
    	int xo = static_cast<int>(i*slide_width - (pred_width - window_width)/2);
   	if(xo >= 0){
    		subseq = seq.substr(xo,  pred_width);
   	}else{
    		subseq = seq.substr(0,  pred_width + xo);
    	}

 	sc = score_seq(subseq, kmer_weights, kmer_size);
 	sc_p = posterior_transform(sc, mu_pos, var_pos, mu_neg, var_neg);
    	score_vect[i] = sc_p;
    }
    return score_vect;
}

// same for bigwig avg scores 
// return (genomic_windows x #experiments) matrix
vector<vector<float>> avgbw_sliding_windows(string seq, int window_width, int slide_width,
                                     vector<string> bwf_list, string chrom, int locus_start, string chain_ID){

    size_t dim = (seq.size() - window_width)/slide_width + 1;
    int N_exp = bwf_list.size();
    vector<vector<float>> score_matrix(dim, vector<float>(N_exp, 0));

    string command; 
    for(int j = 0; j<N_exp; j++){

	string bwfname = "/mnt/data0/joh27/projects/alignment_enhancer_conservation/methods/gkm_dynam/versions/whole_genome/V20/test/HBB/bigwig_outputs/" + chain_ID +"_" + chrom + "_" + to_string(locus_start) + ".bed.out" + "_" + to_string(j);
	check_file(bwfname);
        ifstream avgbwfile(bwfname);
        unsigned int index; string trash; float val; string line; 
        while (getline(avgbwfile, line)) {
           std::istringstream ss(line);
	   ss >> index >> trash >> trash >> trash >> val;
	   if(index < dim){
	   score_matrix[index][j] = val;
	   }
    	}
    }

    return score_matrix;
}




vector<vector<float>> multi_score_sliding_windows(string seq, int window_width, int slide_width,
                                    vector<tuple<int, float, float, float, float, unsigned int>> post_stat_list,
                                    const unordered_map<string, vector<float>>& kmer_weight_matrix){

    size_t dim = (seq.size() - window_width)/slide_width + 1;
    vector<vector<float>> score_matrix(dim);

    unsigned int N_gkm = ((kmer_weight_matrix.begin())->second).size(); 
    vector<float> score_vect(N_gkm);

    int pred_width = get<0>(post_stat_list[0]);
    unsigned int kmer_size = get<5>(post_stat_list[0]);
    float mu_pos; float var_pos; float mu_neg; float var_neg; 

    string subseq;
    for(size_t i = 0; i < dim; i++){
        int xo = static_cast<int>(i*slide_width - (pred_width - window_width)/2);
        if(xo >= 0){
                subseq = seq.substr(xo,  pred_width);
        }else{
                subseq = seq.substr(0,  pred_width + xo);
        }
	score_vect = score_seq_multigkm(subseq, kmer_weight_matrix, kmer_size);
        for(size_t j = 0; j < N_gkm; j++){
            auto& post_stat = post_stat_list[j];
	    mu_pos = get<1>(post_stat); var_pos = get<2>(post_stat);
            mu_neg = get<3>(post_stat); var_neg = get<4>(post_stat);
	    score_vect[j] = posterior_transform(score_vect[j], mu_pos, var_pos, mu_neg, var_neg);
        }
        score_matrix[i] = score_vect;
    }
    return score_matrix;
}


float score_bp(const string& seq, int pos, const unordered_map<string, float>& kmer_weights, int k) {
    int c1 = max(0, pos - k + 1);
    int c2 = min(static_cast<int>(seq.length()) - 1, pos + k - 1);
    string sub = seq.substr(c1, c2 - c1 + 1);
    return score_seq(sub, kmer_weights, k);
}



// used for masking 
vector<float> gen_sc_v(const string& seq, const unordered_map<string, float>& kmer_weights) {
    vector<float> bp_scores;
    int k = ((*(kmer_weights.begin())).first).length();

    for (unsigned int pos = 0; pos < seq.length(); pos++) {
        bp_scores.push_back(score_bp(seq, pos, kmer_weights, k));
    }
    return bp_scores;
}



// mask using non-ATGC ASCII
// return a boolean vector with 1 = masked 0 = not-masked
pair<string, vector<bool>> mask_seq(string seq, unordered_map<string, float>& kmer_weights, float threshold) {

    string masked_seq = seq; 
    vector<float> bp_scores = gen_sc_v(seq, kmer_weights);
    vector<bool> masked_bp(seq.length(), false);
    for (unsigned int i = 0; i < seq.length(); i++) {
        if (bp_scores[i] > threshold) {
            char c= (char) (33 + rand()%32); // special character and numbers
            masked_seq[i] = c;
	    masked_bp[i] = true;
        }
    }
    return make_pair(masked_seq, masked_bp);
}

// For seq of length N, take boolean vector of size N, then convert to percentage of size M, where M is the number of sliding windows, and ith element contain percent NOT masked of ith sliding window.
// Assume that N-w is divisible by s. Else return error. 
vector<float> bool_masked_2_percent_nmasked(vector<bool>& bool_masked, int w, int s){
	unsigned int N = bool_masked.size();
	if((N-w) % s != 0){
		cout << "debug required: in bool_masked_2_percent_nmasked, N-w must be divisible by s" << endl;
		exit(1);
	} else{

		vector<float> percent_nmasked((N-w)/s + 1, 0);
		for(unsigned int i = 0; i < percent_nmasked.size(); i++){
			int n_masked = 0; 
			for(int j = 0; j < w; j++){
				n_masked += bool_masked[i*s + j];
			}
			percent_nmasked[i] = (float)(w-n_masked) / (float)w ;
		}
		return percent_nmasked;

	}
	

}


float train_masker(const unordered_map<string, float>& kmer_weights, string rfile_name, string dir, float fraction_mask){
    check_file(rfile_name);
    ifstream rfile(rfile_name);

    int k = ((*(kmer_weights.begin())).first).length();
    vector<float> vals;  // training val

    int index;
    string line;
    while (getline(rfile, line)) { // looping through bed lines
        cout << line << endl;
        string build; string chrom;
        string start; string end; // string input to include inputs like "." for all
        string fafile_name;
        istringstream ss(line);
        ss >> build >> chrom >> start >> end;
        fafile_name = dir + build + "/" + chrom + ".fa";
        string train_seq = read_fa(fafile_name);
        transform(train_seq.begin(), train_seq.end(), train_seq.begin(), ::toupper);

        if(start == "."){
            start = "0";
        }
        if(end == "."){
            end = to_string(train_seq.size() - 1);
        }

        string subseq; int c1; int c2;
        for(int i = 0; i< (int)train_seq.size(); i++){ // generate training vals
            if(i>=stoi(start) && i<=stoi(end)){
                c1 = i - k + 1;
                c2 = i + k -1;
                if(c1>=0 && c2 < (static_cast<int>(train_seq.length())) - 1){ // full length
                    subseq = train_seq.substr(c1, c2 - c1 + 1);
                    bool unrecog_char = false;
                    for(auto elem : subseq){
                        if(!((elem == 'A') || (elem == 'C') || (elem == 'G') || (elem == 'T'))){
                            unrecog_char = true;
                            break;
                        }
                    }
                    if(!unrecog_char){ //only ATGCatgc
                        vals.push_back(score_bp(train_seq, i, kmer_weights, k));
                    }
                }
            }
        }
        cout << "#sample obtained: " <<  vals.size() << endl;

    }
    sort(vals.begin(), vals.end(), std::greater<float>());
    index = floor(fraction_mask * vals.size());

    float threshold = (vals[index] + vals[index]) / 2;
    return threshold;
}



float pcorr(vector<float> X, vector<float> Y){
   int n = X.size();
   float sum_X = 0, sum_Y = 0, sum_XY = 0;
   float squareSum_X = 0, squareSum_Y = 0;
   for (int i = 0; i < n; i++){
      sum_X = sum_X + X[i];
      sum_Y = sum_Y + Y[i];
      sum_XY = sum_XY + X[i] * Y[i];
      squareSum_X = squareSum_X + X[i] * X[i];
      squareSum_Y = squareSum_Y + Y[i] * Y[i];
   }

   float nume = (float)(n * sum_XY - sum_X * sum_Y);
   float denom = sqrt((n * squareSum_X - sum_X * sum_X) * (n * squareSum_Y - sum_Y * sum_Y)) + 0.000001;
   float corr = nume / denom;
   return corr;
}


vector<float> invert_vector(vector<float> v){
	vector<float> out(v.size(), 0);
	for(unsigned int i = 0; i < v.size(); i++){
		out[v.size() - 1 - i] = v[i];
	}
	return out;
}


vector<float> elem_prod_vectors(vector<float> v1, vector<float> v2){
	vector<float> prod(v1.size());
	for(unsigned int i; i<prod.size(); i++){
		prod[i] = v1[i]*v2[i];
	}
	return prod;
}
#include "header.h"
mutex mtx;

int main(int argc, char *argv[]) {
    srand(1);
    // default parameters
    int lmer_length = 11;
    int non_gap = 7;
    int slide_width = 20;
    int window_width = 300;
    float indel = 0;


    unsigned int n_thread = 1;

    string input_file_type = "NULL";
    // genome directory
    string dir = "NULL";


    // gkm-repeat masker file. contains two lines, each containing gkm-repeat masker file name for build1 and build2
    string rmfile_name = "NULL";

    string annotation_fname = "NULL";
    string annotation_type = "NULL";
    // weighted alignment
    float wF;

    // for bigwig weighting 
    string bwavg_bin_fname; // the bigwigaverageoverbed path
    vector<string> bwf_list_1;
    vector<string> bwf_list_2;
    

    string ifile_name;
    string ofile_directory = "";
    string ofname_prefix = "NULL";
    string cfile_name = "NULL";


    bool output_G_matrix = false;
    bool overwrite = false;

    // for mapping
    string qbuild = "NULL";
    bool multiple_mapping = false;
    bool unique_mapping = false;

    // post gkmsvm weight for alignment
    char opt;
    while ((opt = getopt(argc, argv, ":l:k:s:w:W:i:d:t:g:c:q:p:n:o:mubGOh")) != -1) {
        switch (opt) {
        case 'l':
            lmer_length = atoi(optarg);
            break;
        case 'k':
            non_gap = atoi(optarg);
            break;
        case 's':
            slide_width = atoi(optarg);
            break;
        case 'w':
            window_width = atoi(optarg);
            break;
        case 'i':
            indel = stof(optarg);
            break;
        case 'd':
            dir = string(optarg);
            break;
        case 'g':
            rmfile_name = string(optarg);
            break;
	case 'W': // input type: 0.1,filename
	    //stringstream ss("123,456");//string(optarg));
	    {
	    stringstream ss(optarg);
	    annotation_type = "gkm-SVM";
            string tmp_val;
            getline(ss, tmp_val, ',');
            wF = stof(tmp_val);
            getline(ss, annotation_fname, ',');

	    if(wF<0 || wF>1){
		    cout << "wF must be between 0 and 1" << endl;
		    exit(1);
	    }
	    cout << "Weighted Alignment" << endl;
            cout << "File name: " << annotation_fname << endl;
	    cout << "Weight: " << wF << endl;

	//    help();
            break;
	    }
        case 'c':
            cfile_name = string(optarg);
            break;
	case 'm':
            multiple_mapping = true;
            break;
	case 'u':
            unique_mapping = true;
            break;
        case 't':
            input_file_type = optarg;
            if (input_file_type != "1" &&
                input_file_type != "2") {
                cout << "1 (genomic intervals) 2 (chain for mapping)"
                     << endl;
		help();
                exit(1);
            }
            break;
        case 'p':
            n_thread = atoi(optarg);
            break;

        case 'q':
            qbuild = string(optarg);
            break;
        case 'o':
            ofile_directory = string(optarg);
            if (*(prev(ofile_directory.end())) != '/') {
                ofile_directory = ofile_directory + '/';
            }
            break;
        case 'n':
	    ofname_prefix = string(optarg);
	    break;

        case 'G':
            output_G_matrix = true;
            break;

        case 'O': // currently only for matrix computation.
            overwrite = true;
            break;
        case 'h':
	    help();
            exit(0);

        case ':':
            printf("Missing argument for %c\n", optopt);
	    help();
            exit(1);

        case '?':
            cout << "Unknown option: " << char(optopt) << endl;
	    help();
            exit(1);
        }
    }

    if (input_file_type == "NULL") {
        cout << "option -t (input file type) is required" << endl;
	help();
        exit(1);
    }


    if (input_file_type == "1") { // genomic intervals
        if (dir == "NULL") {
            cout << "For input type 1, option -d (genome file location) is "
                    "required"
                 << endl;
	    help();
            exit(1);
        }
        if (rmfile_name == "NULL") {
            cout << "For input type 1, option -g (genome kmer weight file for masker) is "
                    "required"
                 << endl;
	    help();
            exit(1);
        }


        cout << "\n-- Parameters --" << endl;
        cout << "insertion/deletion penalty: " << indel << endl;
        cout << "l-mer length: " << lmer_length << " (default: 11)" << endl;
        cout << "number of informative base pairs: " << non_gap
             << " (default: 7)" << endl;
        cout << "slide width: " << slide_width << " (default: 20)" << endl;
        cout << "window width: " << window_width << " (default: 300)" << endl;
        cout << "number of parallel threads: " << n_thread << " (default: 1)" << endl;

        if (output_G_matrix) {
            cout << "Matrix matrix G (general sequence similarity) will be generated for each alignment"
                 << endl;
        }


        if (optind + 1 != argc) {
            cout << "One positional argument is required: input file name"
                 << endl;
	    help();
            exit(1);
        } else {
            ifile_name = argv[optind];
        }

        check_file(ifile_name);
        ifstream ifile(ifile_name);



        // output file info
        string init_dir = dirname(ifile_name);
        if (ofile_directory == "") { // if not specified, save it where the input file is located
            ofile_directory = init_dir;
        }
	string coord_ofname;
	if(ofname_prefix != "NULL"){
            coord_ofname = ofile_directory + ofname_prefix + ".coord";
	}else{
	    coord_ofname = ofile_directory + basename(ifile_name) + ".coord"; 
	}


        // prep repeat masker
	ifstream rm_file (rmfile_name);
	string rmodel_fname1;
        string rmodel_fname2;
	getline(rm_file, rmodel_fname1);
        getline(rm_file, rmodel_fname2);

        cout << "Reading masker model: " << rmodel_fname1 <<endl;
        cout << "Reading masker model: " << rmodel_fname2 <<endl;

	
        unordered_map<string, float> masker_weights_1;
        unordered_map<string, float> masker_weights_2;

        const float mthreshold_1 = load_weights_threshold(masker_weights_1, rmodel_fname1);
	const float mthreshold_2 = load_weights_threshold(masker_weights_2, rmodel_fname2);


	tuple<int, float, float, float, float, unsigned int> post_stat_1;
	unordered_map<string, float> kmer_weights_1; // encoding reg vocab
        tuple<int, float, float, float, float, unsigned int> post_stat_2;
        unordered_map<string, float> kmer_weights_2; // encoding reg vocab


	unordered_map<string, vector<float>> kmer_weight_matrix;

	if(annotation_type == "gkm-SVM"){
	// posterior weight file for weighted alignment.
        // w    300
        // mu_pos  -0.4698601590268965
        // var pos 0.0002796103768422355
       // mu_neg  -0.5784510419876551
        // var_neg 0.0010991364946907067
        // CCCCGATATAC     -0.6253484
	    ifstream ifile(annotation_fname);
	    string model_fname;
	    getline(ifile, model_fname);
	    post_stat_1 = load_post_weights(kmer_weights_1, model_fname);
	    getline(ifile, model_fname);
	    post_stat_2 = load_post_weights(kmer_weights_2, model_fname);

        }
	

    //input format
     //some header
	//hg38    chr12   98635113        98655141        mm10    chr10   91072770        91092940        same_strand     chain1
	//
        // count the number of interval lines (excluding the header)
        // This determines how parallel processing will work
        // If nlines>p, each threads take different interval lines
        // else, multiple threads are used to computed a single gkm matrix 
        vector<tuple<string, string, int, int, string, string, int, int, string, string>> all_intervals; 
        string line;
        getline(ifile, line); // skip the header
        while(!ifile.eof()) {
	    getline(ifile, line);
            if(line.length() == 0 ){continue;} // skip empty lines
            istringstream ss(line);
      
            string build1;
            string build1_chr;
            int build1_start;
            int build1_end;

            string build2;
            string build2_chr;
            int build2_start;
            int build2_end;

            string rel_strand_loc; // whether build_1 and build_2's genetic elements are located on the same strand.
            string interval_ID; // e.g. chain id. Doesn't need to be unique

            ss >> build1 >>  build1_chr >> build1_start >>
                build1_end >> build2  >> build2_chr >> build2_start
               >> build2_end  >> rel_strand_loc >> interval_ID;

	    // if negative coordinate provided (possibily by mistake, use max(coord, 0))
	    // going over boundary isn't a problem since read_fa takes that into acccount
	    build1_start = build1_start > 0 ? build1_start : 0;
	    build2_start = build2_start > 0 ? build2_start : 0;

            all_intervals.push_back(make_tuple(build1, build1_chr, build1_start, build1_end,
                                           build2, build2_chr, build2_start, build2_end,
                                           rel_strand_loc, interval_ID));
        }

        // determine thread parameters, and partition the intervals accordingly 
        vector<vector<tuple<string, string, int, int, string, string, int, int, string, string>>> interval_partition;
        int threads_per_matrix;
        if(all_intervals.size() < n_thread){ // |partition| = 1
            threads_per_matrix = n_thread;
            interval_partition.push_back(all_intervals);
        }else{ // |partition| = n_thread
            threads_per_matrix = 1;
            for(unsigned int i = 0; i<n_thread; i++){ // insert empty vectors
                interval_partition.push_back({});
            }

            for(unsigned int i = 0; i<all_intervals.size(); i++){ // partition
                (interval_partition[i%n_thread]).push_back(all_intervals[i]);
            }
            
        }



	// lambda function for parallel threads Matrix F(dim_1, dim_2);
        // to be filled through lambda functions of the threads 
        // chain_ID -> {coordinates, chain_info}
	// coordinates = {coord1, coord2, Gval, Fval}  in case of unweighted alignment, Fval = "."
	// chain_info just contains build, chrom, rel_strand_loc
        map<string, pair<vector<tuple<int, int, string, string, string>>, vector<string>>> chainID_to_coords;
        // lambda function to distribute over multiple threads   
        auto align_intervals = [&](vector<tuple<string, string, int, int, string, string, int, int, string, string>> intervals){ 
           // input: intervals
            static int progress = 0;
            vector<tuple<int, int, string, string, string>> coords; // to be filled after alignment 
            vector<string> chain_info; // For each chain, info on build, chrom, and direction
            string chain_ID; // Intervals from the same chain have the same ID.

            for(auto it = intervals.begin(); it != intervals.end(); it++){ 
                // redefine these variables to avoid thread collisions. 
                string build1 = get<0>(*it);
                string build1_chr = get<1>(*it);
                int build1_start =  get<2>(*it);
                int build1_end = get<3>(*it);

                string build2 = get<4>(*it);
                string build2_chr = get<5>(*it);
                int build2_start = get<6>(*it);
                int build2_end =  get<7>(*it);
                string rel_strand_loc = get<8>(*it); // whether build_1 and build_2's genetic element are located on the same strand.
                string chain_ID = get<9>(*it); // e.g. chain id. Doesn't need to be unique

		if(!(rel_strand_loc =="same_strand" || rel_strand_loc == "diff_strand")){
			cout << "9'th element in the input .2align file must be either 'same_strand' or 'diff_strand'" <<endl;
			exit(1);
		}

		// unique identifier for debugging 
		string ID_2align = build1 + "-" + build1_chr + "-" + to_string(build1_start) + "-" + to_string(build1_end) + "-" +  build2 + "-" + build2_chr + "-" + to_string(build2_start) + "-" + to_string(build2_end) + "-" + rel_strand_loc; 

                chain_info = {build1, build1_chr, build2, build2_chr, rel_strand_loc}; 

                string matrix_pref = ofile_directory + build1 + "-" + build1_chr +
                                "-" + to_string(build1_start) + "-" +
                                to_string(build1_end) + "-" + build2 + "-" +
                                build2_chr + "-" + to_string(build2_start) +
                                "-" + to_string(build2_end) + "-" + rel_strand_loc;

                ifstream ifile(matrix_pref  + ".matrixG");

		// fetch seq 
		string seq_1; string seq_2;
		string mseq_1; string mseq_2; // masked sequences 
		vector<bool> bool_masked_1; vector<bool> bool_masked_2;
		vector<float> percent_nmasked_1; vector<float> percent_nmasked_2;

                pair<string, string> seqs =generate_regions_to_align(dir,
                                    build1, build1_chr, build1_start, build1_end,
                                    build2, build2_chr, build2_start, build2_end,
                                               window_width, slide_width);

                seq_1 = get<0>(seqs);
                seq_2 = get<1>(seqs);

		if((int)seq_1.size() < window_width || (int)seq_2.size() < window_width){continue;}

		// repeat masking
		auto masking_pair_1= mask_seq(seq_1, masker_weights_1, mthreshold_1);
                auto masking_pair_2 = mask_seq(seq_2, masker_weights_2, mthreshold_2);
		mseq_1 = masking_pair_1.first;
		bool_masked_1 = masking_pair_1.second;
		mseq_2 = masking_pair_2.first;
                bool_masked_2 = masking_pair_2.second;


                percent_nmasked_1 = bool_masked_2_percent_nmasked(bool_masked_1, window_width, slide_width);
                percent_nmasked_2 = bool_masked_2_percent_nmasked(bool_masked_2, window_width, slide_width);

       
		// dimension for gkmsim matrix. 
		// To ensure matrix dimension consistency, -w and -s paramters must be kept consistent for de-novo and precomputed matrices.
		size_t dim_1 = (seq_1.size() - window_width)/slide_width + 1;
		size_t dim_2 = (seq_2.size() - window_width)/slide_width + 1;

       	       
		// For weighted alignment
		vector<float> ann_vector_1;
		vector<float> ann_vector_2;
                if(annotation_type == "gkm-SVM"){
		    ann_vector_1 = score_sliding_windows(seq_1, window_width, slide_width, post_stat_1, kmer_weights_1);
		    if(rel_strand_loc == "same_strand"){
                    	ann_vector_2 = score_sliding_windows(seq_2, window_width, slide_width, post_stat_2, kmer_weights_2);
		    }else{
	                ann_vector_2 = score_sliding_windows(revcomp(seq_2), window_width, slide_width, post_stat_2, kmer_weights_2);
		    }

	            ann_vector_1 = elem_prod_vectors(ann_vector_1, percent_nmasked_1); // to correctly weigh repeats .. 
	            ann_vector_2 = elem_prod_vectors(ann_vector_2, percent_nmasked_2);
		}

                if(!overwrite && ifile.good()){ // using pre-exising matrix G
                    cout << "Relevant matrix file already exists in the ouptut directory: "<< matrix_pref  + ".matrixG" <<endl;
                    cout << "The matrix file will be used for alignment" << endl;
                    cout << "Use option -O to overwrite" << endl;
		    Matrix G = Matrix(matrix_pref  + ".matrixG");
		    auto dims = G.dims();
		    if(dims[0] != dim_1 || dims[1] != dim_2){
			    cout << "mismatch between pre-computed matrix dimension and input dimension. Check paramters" << endl;
			    exit(1);
		    } 
                    if(annotation_type == "NULL"){ // unweighted alignment
                    	Seq_Aligner sa(&G, rel_strand_loc, ID_2align);
			vector<tuple<int, int>> aligned_dots = sa.gen_dots(indel);
                        coords =  sa.dots_to_coords(aligned_dots, build1_start, build2_start,
                                  slide_width, window_width, rel_strand_loc);

		    } else { 	 // weighted alignment
			Seq_Aligner sa(&G, &ann_vector_1, &ann_vector_2, wF, rel_strand_loc, ID_2align);
			vector<tuple<int, int>> aligned_dots = sa.gen_dots(indel);
                        coords =  sa.dots_to_coords(aligned_dots, build1_start, build2_start,
                                  slide_width, window_width, rel_strand_loc);
		    }

                } else { // de novo matrix computation
                    MatrixG_Computer kc(lmer_length, non_gap, slide_width, window_width,
                               mseq_1, mseq_2, rel_strand_loc, threads_per_matrix);

		    if((dim_1 == 1) || (dim_2 ==1)){
                        cout << "Alignment skipped because gkm matrix width or height is too small"<< endl;
			mtx.lock();
                        progress++;
                        mtx.unlock();
                        continue;
                    }

                    Matrix& G = kc.compute_full_matrix();
                    if (output_G_matrix) {
			G.save_matrix(matrix_pref + ".matrixG");
                    }

                    if(annotation_type == "NULL"){ // unweighted alignment
                        Seq_Aligner sa(&G, rel_strand_loc, ID_2align);
                        vector<tuple<int, int>> aligned_dots = sa.gen_dots(indel);
                        coords =  sa.dots_to_coords(aligned_dots, build1_start, build2_start,
                                  slide_width, window_width, rel_strand_loc);

                    } else { // weighted alignment

                        Seq_Aligner sa(&G, &ann_vector_1, &ann_vector_2, wF, rel_strand_loc, ID_2align);

                        vector<tuple<int, int>> aligned_dots = sa.gen_dots(indel);

                        coords =  sa.dots_to_coords(aligned_dots, build1_start, build2_start,
                                  slide_width, window_width, rel_strand_loc);


                    }
                } // end of if-else

                mtx.lock();
                if(chainID_to_coords.find(chain_ID) == chainID_to_coords.end()){ // new chain
                    chainID_to_coords[chain_ID] = make_pair(coords, chain_info);   
                }else{ // chain exists
                    auto& chain_coords = get<0>(chainID_to_coords[chain_ID]);
                    chain_coords.insert(chain_coords.end(), coords.begin(), coords.end());
                }
                progress++;
                cout << progress << "/" << all_intervals.size() << " intervals aligned."<< endl; 
                mtx.unlock();
            } // end of for
        };     // end of the lambda function
        // now distribute the intervals to multiple threads 



        vector<thread> workers;
        for(unsigned int i = 1; i<interval_partition.size(); i++){ // leave one out for the current thread 
            workers.push_back(thread(align_intervals, interval_partition[i]));
        }
        align_intervals(interval_partition[0]);

        for(auto& worker : workers){
            worker.join();
        }

        ofstream ofile_coords;
        ofile_coords.open(coord_ofname);

        for(auto it : chainID_to_coords){
            auto& chainID = it.first;
            auto& coords = get<0>(it.second);
            auto& chain_info = get<1>(it.second); // build1, build1_chr, build2, build2_chr, dir


            // sort by build1 coord
            // within chain, guaranteed to be colinear, so can be sorted using either coordinates 
            sort(coords.begin(), coords.end(),
            [](const tuple<int, int, string, string, string> &a, // build1 coord, build2 coord, Gval, Fval
               const tuple<int, int, string, string, string> &b) -> bool {
                return std::get<0>(a) > std::get<0>(b); 
            });
            int min_coord1 = min(get<0>(coords[0]), get<0>(coords.back())) - window_width/2;
            int max_coord1 = max(get<0>(coords[0]), get<0>(coords.back())) + window_width/2;
            int min_coord2 = min(get<1>(coords[0]), get<1>(coords.back())) - window_width/2;
            int max_coord2 = max(get<1>(coords[0]), get<1>(coords.back())) + window_width/2;
            ofile_coords << ">" << "\t"  << chainID << "\t" << chain_info[0] << "\t" << chain_info[1] << "\t" << min_coord1<<"\t"<< max_coord1 
                                            <<"\t" << chain_info[2] << "\t" << chain_info[3] << "\t" << min_coord2 << "\t" <<max_coord2
                                            <<  "\t" << chain_info[4] << endl;


            for(auto& coord : coords){
                ofile_coords << get<0>(coord) << "\t" << get<1>(coord) << "\t"<<get<2>(coord) << "\t"<< get<3>(coord) << "\t" << get<4>(coord) << endl;
            }
 
            ofile_coords << endl;
        }
        ofile_coords.close();

    } else if (input_file_type == "2") { // positional argument: .bed. extra

        if (cfile_name == "NULL") {
            cout
                << "For input type 1, option -c (build_to_build.coord file) is "
                   "required"
                << endl;
	    help();
            exit(1);
        }



        if (optind + 1 != argc) {
            cout << "One positional argument is required: query bed file"
                 << endl;
	    help();
            exit(1);
        } else {
            ifile_name = argv[optind];
        }

        check_file(ifile_name);
        ifstream ifile(ifile_name);

        if (qbuild == "NULL") {
            cout << "For type -2, must specify the name of the query build (e.g. mm10) after -q" << endl;
	    help();
            exit(1);
        }

        string init_dir = dirname(ifile_name);
        if (ofile_directory ==  "") { // if not specified, save it where the input file is located
            ofile_directory = init_dir;
        }


	if(unique_mapping + multiple_mapping != 1){
	    cout << "Exactly one of -m (multiple) or -u (unique) must be provided" << endl;
	    help();
	    exit(1);
	}

        string ofname_mapped;
        string ofname_nmapped;

	if(ofname_prefix == "NULL"){
		ofname_prefix = basename(ifile_name);
	}
	
        if(multiple_mapping){
            ofname_mapped = ofile_directory + ofname_prefix + ".multiple_mapped";
            ofname_nmapped = ofile_directory + ofname_prefix + ".multiple_not_mapped"; 
        } else if(unique_mapping) {
            ofname_mapped = ofile_directory + ofname_prefix + ".unique_mapped";
            ofname_nmapped = ofile_directory + ofname_prefix + ".unique_not_mapped"; 
        }


        ofstream ofile_mapped;
        ofstream ofile_nmapped;
        ofile_mapped.open(ofname_mapped);
        ofile_nmapped.open(ofname_nmapped);




       // input bed file either has unique IDs for each bed lines in the fourth column, or empty
        // first, read in all the bed lines 
        vector<tuple<string, int, int, string>> bed_inputs;
        vector<string> qchrom_list; // to read in only the chain lines that are necessary
	string line;
        while (!ifile.eof()){
            getline(ifile, line);
            if(ifile.eof()){continue;}

            string chr;
            int start; //  start coordinate for each bed lines
            int end; // end "
	    string bed_id = "";
            istringstream ss(line);
            ss >> chr >> start >> end >> bed_id;

            if(bed_id.length() == 0){ // if no id given, make one 
                bed_id = chr + ":" + to_string(start) + "-" + to_string(end);
            }           
         
            bed_inputs.push_back(make_tuple(chr, start, end, bed_id));
            qchrom_list.push_back(chr);
        }

        cout<<"Initializing Mapper"<<endl;
        Mapper mp(cfile_name, qbuild, qchrom_list);
	cout<<"Mapper loaded" << endl;

        for(auto& query_bed : bed_inputs){
            string chr = get<0>(query_bed);
            int start = get<1>(query_bed);
            int end = get<2>(query_bed); 
            int width = (end-start);

            string bed_id = get<3>(query_bed);
            vector<string> matched_chains = mp.identify_chains(chr, start, end); 

	    // no matching chain 
	    if(matched_chains.size() == 0){
                ofile_nmapped << "# deleted in " << mp.get_tbuild()  <<endl;
                ofile_nmapped << chr + "\t" << start  << "\t" << end << "\t" <<bed_id<<endl;
	        continue;
            }
	    
	    // First, obtain a list of all mappings of the given bed
	    vector<tuple<string, int, int, string>> mapping_list_init = {}; // container for mapped loci
	    // loop through all mapped chains 
            for(unsigned int i = 0; i<matched_chains.size(); i++){
                string chain_id = matched_chains[i];
                vector<tuple<int, int, string>>& coords = mp.get_coords(chain_id);

                tuple<int, int, string> coord = mp.search_query(coords, start, end);
                if(get<0>(coord) != -1){
                    mapping_list_init.push_back(make_tuple(mp.get_tchrom(chain_id), max(0, get<1>(coord) - width/2), get<1>(coord)+ width/2, get<2>(coord)));
                }
            }


	    // scan the initial mapping list, and search for trivial duplicates (significant overlap with other mapping)
	    // sig overlap : overlapped bp is at least half the size of the query bed. 
	    // Merge the trivial duplicates 
	    vector<tuple<string, int, int, string>> mapping_list_final = {}; 
            for(auto& map1 : mapping_list_init){
	        bool trivial_dup = false;
		unsigned int i = 0;
		// check existence for trivial duplication then merge. 
		while(i<mapping_list_final.size() && !trivial_dup){
		    auto& map2 = mapping_list_final[i];
		    bool same_chrom = (get<0>(map1) == get<0>(map2)); 
		    int bp_overlap = min(get<2>(map1), get<2>(map2)) - max(get<1>(map1), get<1>(map2));
		    bool sig_overlap = (bp_overlap > width/2); 
		    if(same_chrom && sig_overlap){
			trivial_dup = true; 
	                get<1>(map2) = min(get<1>(map1), get<1>(map2));
			get<2>(map2) = max(get<2>(map1), get<2>(map2));
		    }
		    i++;
		}


		if(!trivial_dup){
		    mapping_list_final.push_back(map1);
	        }
	    }

            int ncopy = mapping_list_final.size();
	    // matched chain but the input bed line doesn't overlap with any coords
	    if(ncopy == 0){
                ofile_nmapped << "# deleted in " << mp.get_tbuild()  <<endl;
                ofile_nmapped << chr + "\t" << start  << "\t" << end << "\t" <<bed_id<<endl;
                continue;
            }

            if(multiple_mapping){
                for(unsigned int i = 0; i < mapping_list_final.size(); i++){
		    auto& mapped_locus = mapping_list_final[i]; 
                    ofile_mapped << get<0>(mapped_locus) << "\t" << get<1>(mapped_locus)
                                 << "\t" << get<2>(mapped_locus) << "\t" << bed_id
                                 <<  "\t" << i+1 << "\t" << get<3>(mapped_locus)  <<endl;
                }
            } else if(unique_mapping){
	        if(ncopy == 1){
		    auto& mapped_locus = mapping_list_final[0];
		    ofile_mapped << get<0>(mapped_locus) << "\t" << get<1>(mapped_locus)
                                 << "\t" << get<2>(mapped_locus) << "\t" << bed_id
                                 << "\t" << get<3>(mapped_locus)  <<endl;
                }else if (ncopy>=2){ 
                    ofile_nmapped << "# duplicated in " <<  mp.get_tbuild() <<endl;
                    ofile_nmapped << chr << "\t" << start << "\t" << end << "\t" << bed_id<<endl;
                }else{
                    cout << "debug needed (MAPPER-0mapped)" << endl;
		    exit(1);
                }
            } else{
		    cout << "debug required" << endl;
		    exit(1);
	    }
	}
        cout << "Finished mapping" << endl;
        ofile_mapped.close();
        ofile_nmapped.close();
        ifile.close();
    }
    return 0;
}
#include "header.h"

// constructor
// current version keeps input bed and out bed width identical. (e.g. 300bp --> 300bp)
//cfile = coordinate chain file 
Mapper::Mapper(string cfile_name, string qbuild, vector<string> qchrom_list) {
    check_file(cfile_name);
    ifstream cfile(cfile_name);

    // format
    // >	1   mm10    chr7    103847958       103886990       hg38    chr11   5267504 5306699 same_strand
    // 103847958       5267504 0.0378858
    // 103847978       5267524 0.0334759

    // chain_id build1 build1_chr range_start range_end build2 build2_chr range_start range_end dir


    // save the alignment result (build_to_build.coord) into a map
    // Partition by chromosome, and sort by position for each chroms.

    // for chain info line
    string trash;
    string chain_id;
    string build1;
    string build1_chr;
    int build1_start;
    int build1_end;
    string build2;
    string build2_chr;
    int build2_start;
    int build2_end;
    string rel_strand;
   

    // for coordinate lines 
    int coord1; 
    int coord2;
    string cons_vals; // for unweighted alignment, one float. For weighted, three floats

    string qchrom; 

    string line;
    bool skip = true; 

    while (getline(cfile, line)) {
        istringstream ss(line);
        if(line[0] == '>'){ // new chain
	    skip = true; 
            ss >> trash >> chain_id >>build1 >> build1_chr >> build1_start >> build1_end
               >> build2 >> build2_chr >> build2_start >> build2_end >> rel_strand;

            if(build1 == qbuild){
                qdim = 0;
                qbuild = build1;
                tbuild = build2;
                qchrom = build1_chr; 
           } else if(build2 == qbuild){
                qdim = 1;
                qbuild = build2;
                tbuild = build1;
                qchrom = build2_chr;
            } else {
                cout << "ERROR: " << qbuild << " does not match any of the builds in the input chain file" << endl;
                exit(1);
            }
 
            if(find(qchrom_list.begin(), qchrom_list.end(), qchrom) != qchrom_list.end()){ // chain lies in query relevant chromosmes
	        skip = false; 
            // fill in chrom_to_cinfo
                if(qdim == 0){
                    if (chrom_to_cinfo.find(build1_chr) == chrom_to_cinfo.end()){
                        chrom_to_cinfo[build1_chr] = {make_tuple(chain_id, build1_start, build1_end)};
                    } else {
                        (chrom_to_cinfo[build1_chr]).push_back(make_tuple(chain_id, build1_start, build1_end));
                    }

                    chainID_to_tchrom[chain_id] = build2_chr;

                } else {
                    if (chrom_to_cinfo.find(build2_chr) == chrom_to_cinfo.end()){
                        chrom_to_cinfo[build2_chr] = {make_tuple(chain_id, build2_start, build2_end)};
                    } else {
                        (chrom_to_cinfo[build2_chr]).push_back(make_tuple(chain_id, build2_start, build2_end));
                    }
                    chainID_to_tchrom[chain_id] = build1_chr;
                }
	    }

        // fill in chainID_to_coords. for coords, first dimension is the query dimension.
        } else {
		//v1: gkmsim; v2,v3: gkm-SVM.  for unweighted, v2,v3=.,.
		string v1;
		string v2; 
		string v3;
	    if(!skip){
                ss >> coord1 >> coord2  >> v1 >> v2 >> v3;
		cons_vals = v1 + "\t" + v2 + "\t" + v3;
                if(qdim == 0){
                    if(chainID_to_coords.find(chain_id) == chainID_to_coords.end()){
                        chainID_to_coords[chain_id] = {make_tuple(coord1, coord2, cons_vals)};
                    } else{
                        (chainID_to_coords[chain_id]).push_back(make_tuple(coord1, coord2, cons_vals)); 
                    }            
                } else {
                    if(chainID_to_coords.find(chain_id) == chainID_to_coords.end()){
                        chainID_to_coords[chain_id] = {make_tuple(coord2, coord1, cons_vals)};
                    } else{
                        (chainID_to_coords[chain_id]).push_back(make_tuple(coord2, coord1, cons_vals));
                    }

                }
	    }
        }
    }

    // now, sort coords for each chain. sort by query coordinate
    for(auto& item : chainID_to_coords){
        auto& coords = item.second;
        sort(coords.begin(), coords.end(),
             [](const tuple<int, int, string> &a, const tuple<int, int, string> &b) -> bool {
                return get<0>(a) < get<0>(b);
        });
        
    }
    cfile.close();
}

// return a list of chains that overlap with the given bed coordinate 
// uses data stored in chrom_to_cinfo
// // chrom -> vector of {chain_id, range_begin, range_end}
vector<string> Mapper::identify_chains(string chr, int start, int end){
    vector<tuple<string, int, int>>& chain_infos = chrom_to_cinfo[chr];

    vector<string> output_chain_list = {};
    for(auto& chain_info : chain_infos){
        bool overlap = min(end, get<2>(chain_info)) > max(start, get<1>(chain_info)); 
        if(overlap){
            output_chain_list.push_back(get<0>(chain_info));
        } 
    }
    return output_chain_list;
}

vector<tuple<int, int, string>>& Mapper::get_coords(string chain_id){
    return chainID_to_coords[chain_id];
}


// input coord is sorted by the first element (query coord)
// obtain all query coordinates  that is contained within the query range 
tuple<int, int, string> Mapper::search_query(vector<tuple<int, int, string>>& coord_list, int qstart, int qend) {
    // start with binary search
    int lower = 0;
    int upper = coord_list.size();
    int x;
    int val;

    int query = (qstart+qend)/2;
    bool found = false;
    while (lower+1 < upper) {
        x = lower + (upper - lower) / 2;
        val = get<0>(coord_list[x]);
        if (query == val) {
            found = true;
            break; // found. But proceed to scan its neighbors to find one with the highest matrix
        } else if (query > val) {
            lower = x;
        } else if (query < val) {
            upper = x;
        }
    }

    int index = -1; // index to the current best matching coordinate to the target genomic coordinate.  
    if(found){ // exact match found
        index = x;
    } else if((qstart < get<0>(coord_list[lower]) && qend > get<0>(coord_list[lower])) ||
            (qstart < get<0>(coord_list[upper]) && qend > get<0>(coord_list[upper])) ){ 
    // lower and upper index differ by one. Either lower or upper has acceptable search solution (contained within query range)
        int d_lower = abs(query - get<0>(coord_list[lower]));
        int d_upper = abs(query - get<0>(coord_list[upper]));
        if(d_lower < d_upper){ // lower is better
            index = lower;
        }else{ // upper is better
            index = upper;
        }
    } else{ // no acceptable match found 
        return make_tuple(-1,-1,"0"); 
    }



    return coord_list[index];

}


string Mapper::get_tchrom(string chainID){
    return chainID_to_tchrom[chainID];
}

string Mapper::get_tbuild(){
    return tbuild;
}
#include "header.h"
// assumes contiguous nucleotides are given in a single line.
// i.e. for genome.fa files, they need to be preprocessed. 

string mask_seq_lc(string seq, const unordered_map<string, float>& kmer_weights, const float threshold) {

    vector<float> bp_scores = gen_sc_v(seq, kmer_weights);
    for (unsigned int i = 0; i < seq.length(); i++) {
        if (bp_scores[i] > threshold) {
            seq[i] = tolower(seq[i]);
        }
    }
    return seq;
}



int main(int argc, char *argv[]) {
    if(argc != 4){
        cout << "Usage <0> <ifile name>  <masker model> <ofile name>" <<endl;
        exit(1);
    }

   string ifile_name = argv[1];
   check_file(ifile_name);
   ifstream ifile(ifile_name);

   unordered_map<string, float> kmer_weights;
   float threshold = load_weights_threshold(kmer_weights, argv[2]);

   ofstream ofile;
   ofile.open(argv[3]);

    string line; 
    while (!ifile.eof()){
        getline(ifile, line);
	if(line[0] == '>'){
	    ofile << line << endl;
	}else{
	   string seq = line;
	   seq = preprocess_seq(seq);
           seq = mask_seq_lc(seq, kmer_weights, threshold); 
	   ofile << seq << endl;
	}
    }
    ofile.close();
    ifile.close();
    return 0;
}



#include "header.h"




// constructor
Matrix::Matrix(size_t nr, size_t nc): n_rows(nr),  n_cols(nc),  data(nr * nc)
{}

Matrix::Matrix(size_t nr, size_t nc, float val): n_rows(nr),  n_cols(nc),  data(nr * nc, val)
{}

// binary file containing (int)num_row, (int)num_col, val1, val2, ...
Matrix::Matrix(string fname){
	check_file(fname);
	ifstream ifile;
	ifile.open(fname, ios::in | ios::binary);
	ifile.read(reinterpret_cast<char*>(&n_rows), sizeof(size_t));
	ifile.read(reinterpret_cast<char*>(&n_cols), sizeof(size_t));
	data.resize(n_rows*n_cols);

	ifile.read(reinterpret_cast<char*>(&data[0]), n_rows*n_cols*sizeof(float));
	ifile.close();
}


//  update val
float& Matrix::operator()(size_t i, size_t j){
    return data[i * n_cols + j];
}

// return val
float Matrix::operator()(size_t i, size_t j) const{
    return data[i * n_cols + j];
}

vector<size_t> Matrix::dims(){
    return {n_rows, n_cols};
}

float Matrix::compute_mean(){
    float mean = 0;
    for (size_t i = 0; i < n_rows; i++) {
        for (size_t j = 0; j < n_cols; j++) {
            mean = mean + data[i * n_cols + j];
        }
    }
    return mean/(n_cols*n_rows);
}

float Matrix::compute_var(){
    float var = 0;
    float mean = this->compute_mean();
    for (size_t i = 0; i < n_rows; i++) {
        for (size_t j = 0; j < n_cols; j++) {
            var = var + pow(data[i * n_cols + j] - mean, 2);
        }
    }
    var = var / (n_rows * n_cols - 1);
    return var;
}

void Matrix::weigh_rows_by_vect(vector<float> v){
    if(v.size() != n_rows){
	    cout << "dimension mismatch in weigh_rows_by_vect" << endl;
	    exit(1);
    }
    for (size_t i = 0; i < n_rows; i++) {
        for (size_t j = 0; j < n_cols; j++) {
            data[i * n_cols + j] *= v[i];
        }
    }
}

void Matrix::weigh_cols_by_vect(vector<float> v){
    if(v.size() != n_cols){
            cout << "dimension mismatch in weigh_cols_by_vect" << endl;
            exit(1);
    }
    for (size_t j = 0; j < n_cols; j++) {
        for (size_t i = 0; i < n_rows; i++) {
            data[i * n_cols + j] *= v[j];
        }
    }
}




void Matrix::rowwise_avgdotproduct_matrices(vector<vector<float>> M1, vector<vector<float>> M2, string rel_strand_loc){
    if(M1.size() != n_rows || M2.size() != n_cols){
        cout << "dimension mismatch" << endl;
        exit(1);
    }else{

	float dp;
	unsigned int N;
        vector<float> p1; vector<float> p2; 
        for(unsigned int i = 0 ; i < n_rows; i++){
            p1 = M1[i];
            for(unsigned int j = 0; j < n_cols; j++){
                if(rel_strand_loc == "same_strand"){
                    p2 = M2[j];
                }else{
                    p2 = M2[M2.size()-1-j];
                }

		N = p1.size(); 
		dp = 0;
		for(unsigned int k = 0; k < N; k++){
			dp = dp + p1[k]*p2[k];
		}
                data[i*n_cols + j] = dp / N;
            }
        }
    }
}


// row-wise corr (using pearson corr) between two (max-filtered) matrices
void Matrix::rowwise_pcorr_matrices(vector<vector<float>> M1, vector<vector<float>> M2, float max_filter, string rel_strand_loc){
    if(M1.size() != n_rows || M2.size() != n_cols){
        cout << "dimension mismatch" << endl;
        exit(1);
    }else{

	vector<float> p1; vector<float> p2; float max1; float max2;
        for(unsigned int i = 0 ; i < n_rows; i++){
	    p1 = M1[i];
            for(unsigned int j = 0; j < n_cols; j++){
		if(rel_strand_loc == "same_strand"){
		    p2 = M2[j];
		}else{
		    p2 = M2[M2.size()-1-j];
		}

                max1 = *max_element(begin(p1), end(p1));
                max2 = *max_element(begin(p2), end(p2));

                float filter1 = 0 ; float filter2 = 0;
                if(max1>max_filter){
                    filter1 = 1;
                }
                if(max2>max_filter){
                    filter2 = 1;
                }

                data[i*n_cols + j] = (pcorr(p1, p2) + 1 ) /2 * filter1 * filter2;
            }
        }
    }
}
 


// save matrix in binary format 
int Matrix::save_matrix(string fname){
	ofstream ofile;   
	ofile.open(fname, ios::out | ios::binary);
	ofile.write(reinterpret_cast<char*>(&n_rows), sizeof(size_t));
	ofile.write(reinterpret_cast<char*>(&n_cols), sizeof(size_t));
	ofile.write(reinterpret_cast<char*>(&data[0]), data.size()*sizeof(float)); 
	ofile.close();
	return 0;
}


// save in human readable .tsv format 
int Matrix::save_matrix_tsv(string fname){
	ofstream ofile;
        ofile.open(fname);
	for(unsigned int i = 0; i < n_rows; i++){
		for(unsigned int j = 0; j < n_cols; j++){
			ofile << data[i*n_cols + j] << "\t";
		}
		ofile << "\n";
	}
        ofile.close();
        return 0;
}





#include "header.h"

MatrixG_Computer::MatrixG_Computer(int lmer_length,
                                 int nongap_length,
                                 int slide_width,
                                 int window_width, string seq1,
                                 string seq2, string rel_strand_loc, int threads):

    l(lmer_length),
    k(nongap_length),
    slide(slide_width),
    window(window_width),
    n_thread(threads),
    seq1(seq1),
    seq2(seq2),
    km_dim_1(1 + (seq1.length() - window_width) / slide_width),
    km_dim_2(1 + (seq2.length() - window_width) / slide_width),
    K(km_dim_1, km_dim_2, 0),
    rel_strand_loc(rel_strand_loc)
{

    // handle revcomp 
    if (rel_strand_loc == "same_strand") {
        // do nothing
    } else if (rel_strand_loc == "diff_strand") {
       seq2 = revcomp(seq2);
    } else {
        cout << "Unrecognized relative strand location: " + rel_strand_loc << endl;
        exit(1);
    }


    // SIMD vectorization: obtain all subseqs of size l
    // v[i] = seq[i:i+l] + pads
    string pad1(32-l, '>'); // 32 for AVX2, 16 for SSE
    string pad2(32-l, '<');
    for(unsigned int i = 0; i<seq1.length() - l + 1; i++){
	    seq1_sv_a.push_back(seq1.substr(i, l) +  pad1);
	    seq1_sv_b.push_back(seq1.substr(i, l) +  pad2);

	    seq1_pv_a.push_back( &((seq1_sv_a[i])[0]));
            seq1_pv_b.push_back( &((seq1_sv_b[i])[0]));
    }
    for(unsigned int i = 0; i<seq2.length() - l + 1; i++){
	    seq2_sv_a.push_back(seq2.substr(i, l) +  pad1);
            seq2_sv_b.push_back(seq2.substr(i, l) +  pad2);

	    seq2_pv_a.push_back( &((seq2_sv_a[i])[0]));
            seq2_pv_b.push_back( &((seq2_sv_b[i])[0]));
    }



    // initializing 3-dimenasional array
    pm_dim_1 = km_dim_1 - 1 + window / slide;
    pm_dim_2 = km_dim_2 - 1 + window / slide;

    // pre-computing values that will be repeatedly used
    for (int m = 0; m < l + 1; m++) {
        if ((l - m) >= k) {
            shared_gkm.push_back(nchoosek(l - m, k));
        } else {
            shared_gkm.push_back(0);
        }
    }


    init_norm(v1_norm, seq1_pv_a, seq1_pv_b, km_dim_1);
    init_norm(v2_norm, seq2_pv_a, seq2_pv_b, km_dim_2);
} // end of constructor 1




// computes list of vector norms for the denominator of
// <s1,s2>/sqrt(<s1,s1>)*sqrt(<s2,s2>)
void MatrixG_Computer::init_norm(vector<float> &norm, vector<char*> &seq_v_a, vector<char*> &seq_v_b, 
                                int km_dim) {
    float val;
    for (int i = 0; i < km_dim; i++) {
            val = subseqs_matrix(seq_v_a, seq_v_b, i*slide, i*slide + window - 1, i*slide, i*slide + window - 1);
            norm.push_back(val);
    }

    for (auto it = norm.begin(); it != norm.end(); it++) {
        *it = sqrt(*it);
    }
} // end of method




// given subseq indices, compute <sub1, sub2>. To be uesd in compute_matrix
float MatrixG_Computer::subseqs_matrix(vector<char*> &seq1, vector<char*> &seq2,
                                      int start_i, int end_i,
                                      int start_j,
                                      int end_j) {
    int tot = 0;
    __m256i s1, s2, ceq;
    int match;
    for (int i = start_i; i <= end_i - l + 1; i++) {
        for (int j = start_j; j <= end_j - l + 1; j++) {
            s1 =  _mm256_loadu_si256((__m256i*)(seq1[i]));
            s2 =  _mm256_loadu_si256((__m256i*)(seq2[j]));
            ceq = _mm256_cmpeq_epi8(s1, s2);
            match = __builtin_popcount(_mm256_movemask_epi8(ceq));
            tot += shared_gkm[l - match];
        }
    }
 
    return static_cast<float>(tot);
} // end of method




// multithread computation
Matrix& MatrixG_Computer::compute_full_matrix(){
    vector<thread> workers;
    vector<vector<int>> allocation;
    int curr = 0;

    // leave one out for the current node. 
    for(int i = 0; i < n_thread - 1; i++){
        vector<int> vec;
        int init = curr;
        for(int j = 0; j < km_dim_1/n_thread; j++){
            vec.push_back(init + j);
            curr++;
        }
        allocation.push_back(vec);
    }
    for(int i = 0; i < n_thread-1; i++){
        workers.push_back(thread(&MatrixG_Computer::compute_matrix_rows, this, allocation[i]));
    }
    vector<int> rows;
    for(int i = curr; i < km_dim_1; i++){
        rows.push_back(i);
    }

    compute_matrix_rows(rows);
    for(auto& worker : workers){
        worker.join();
    }
    return K;

}


// compute matrix by row. Useful for multithreading
void MatrixG_Computer::compute_matrix_rows(vector<int> rows){

    if(slide>=l){ // faster version. But it uses lots of memory, so we need further memory optimization by freeing/allocating memory wisely
        int*** piece_container = new int **[pm_dim_1];
        for(unsigned int i = 0; i<rows.size(); i++){
            int row = rows[i];
            //--------------- memory handling------------------ ////
            if(i == 0){ // memory handling: initialize and allocate PM rows
                for(int a = 0; a < window/slide; a++) {
                    piece_container[row + a] = new int *[pm_dim_2];
                    for(int b = 0; b<pm_dim_2; b++) {
                        piece_container[row + a][b] = new int[4];
                        for(int c = 0; c<4; c++){
                            piece_container[row + a][b][c] = -1;
                        }
                    }
                }

            } else{ // memory handling: allocate next row in piece-container and free the row that will no longer be used
                piece_container[row + window/slide - 1] = new int *[pm_dim_2];
                for(int b = 0; b<pm_dim_2; b++) {
                    piece_container[row + window/slide - 1][b] = new int[4];
                    for(int c = 0; c<4; c++){
                        piece_container[row + window/slide - 1][b][c] = -1;
                    }
                }

                for(int j=0; j<pm_dim_2; j++){
                    delete[] piece_container[row - 1][j];
                }
                delete[] piece_container[row - 1];
            }
            // -------------------actual computation----------------//
            
            for(int j = 0; j<km_dim_2; j++){ 
                K(row, j) = compute_sliding_matrix(row,j, piece_container);
            }
            // ------------------------------------------------------//

            //memory handling: if last row, free all the remaining elements
            if(i==rows.size()-1){
                for(int r = row; r<row+window/slide; r++){
                    for(int c=0; c<pm_dim_2; c++){
                        delete[] piece_container[r][c];
                    }
                    delete[] piece_container[r];
                }
            }
        }
        delete[] piece_container;
    } else {
        for(auto row : rows) {
            float kern;
            for(int j = 0; j<km_dim_2; j++){
                kern = subseqs_matrix(seq1_pv_a, seq2_pv_b, slide*row, slide*row + window-1, slide*j, slide*j+window-1);
		K(row,j) = kern / (v1_norm[row] * v2_norm[j]);  
            }
        }
    }
}


// elements for computing matrix by sliding. 
int MatrixG_Computer::compute_piece(int pm_coord_1, int pm_coord_2, string piece_type) {
    if(piece_type == "center"){
        return subseqs_matrix(seq1_pv_a, seq2_pv_b, pm_coord_1 * slide,
                          (pm_coord_1 + 1) * slide - 1, pm_coord_2 * slide,
                          (pm_coord_2 + 1) * slide - 1);
    } else if(piece_type == "right") {
        return subseqs_matrix(seq1_pv_a, seq2_pv_b, pm_coord_1 * slide, (pm_coord_1 + 1) * slide - 1,
        (pm_coord_2 + 1) * slide - l + 1, (pm_coord_2 + 1) * slide + l - 2);

    } else if(piece_type == "down") {
        return subseqs_matrix(seq1_pv_a, seq2_pv_b, (pm_coord_1 + 1) * slide - l + 1,
                          (pm_coord_1 + 1) * slide + l - 2, pm_coord_2 * slide,
                          (pm_coord_2 + 1) * slide - 1);
    } else if (piece_type == "both") {
        return subseqs_matrix(seq1_pv_a, seq2_pv_b,(pm_coord_1 + 1) * slide - l + 1,
                                      (pm_coord_1 + 1) * slide + l - 2,
                                      (pm_coord_2 + 1) * slide - l + 1,
                                      (pm_coord_2 + 1) * slide + l - 2);
    } else {
        cout << "Debug required: unrecognized piece type: " << piece_type <<endl;
        return 0;
    }
} // end of method




// no redundant computation in sliding.
// compute row vector of the matrix matrix whose index in specified by curr_row variable. 
float MatrixG_Computer::compute_sliding_matrix(int row, int col, int*** piece_container){

    float kern = 0; 
    // now start row matrix computationi
    int pm_coord_1;
    int pm_coord_2;
    for (int a = 0; a < window / slide; a++) {
        for (int b = 0; b < window / slide; b++) {
            pm_coord_1 = row + a;
            pm_coord_2 = col + b;
            // pieces for each piece matrix elements. Use reference to update
            // the
            // target, not a copy.
            int &center = piece_container[pm_coord_1][pm_coord_2][0];
            int &right = piece_container[pm_coord_1][pm_coord_2][1];
            int &down = piece_container[pm_coord_1][pm_coord_2][2];
            int &both = piece_container[pm_coord_1][pm_coord_2][3];
            if (b == (window / slide - 1) && a < window / slide - 1) { // last column but not last row. box
                                          // with down arrow
                if (center < 0) {
                    center = compute_piece(pm_coord_1, pm_coord_2, "center");
                }
                kern += center;

                if (down < 0) {
                    down = compute_piece(pm_coord_1, pm_coord_2, "down");
                }
                kern += down;

            } else if (a == (window / slide - 1) &&
                           b < window / slide -
                                   1) { // last row but not last column. box
                                    // with right arrow
                if (center < 0) {
                    center = compute_piece(pm_coord_1, pm_coord_2, "center");
                }
                kern += center;

                if (right < 0) {
                    right = compute_piece(pm_coord_1, pm_coord_2, "right");
                }
                kern += right;

            } else if (a == (window / slide - 1) &&
                           b == (window / slide -
                                     1)) { // last row and column. box with no arrow
                if (center < 0) {
                    center = compute_piece(pm_coord_1, pm_coord_2, "center");
                }
                kern += center;

            } else { // box with both right and down arrow
                if (center < 0) {
                    center = compute_piece(pm_coord_1, pm_coord_2, "center");
                }
                kern += center;

                if (down < 0) {
                    down = compute_piece(pm_coord_1, pm_coord_2, "down");
                }
                kern += down;

                if (right < 0) {
                    right = compute_piece(pm_coord_1, pm_coord_2, "right");
                }
                kern += right;

                if (both < 0) {
                    both = compute_piece(pm_coord_1, pm_coord_2, "both"); 
                }
                kern += both;
            }
        }
    }
    return kern / (v1_norm[row] * v2_norm[col]);
} // end of method



vector<int> MatrixG_Computer::get_km_dim() {
    vector<int> dim = {km_dim_1, km_dim_2};
    return dim;
}

string MatrixG_Computer::get_rel_strand_loc() { return rel_strand_loc; }


int MatrixG_Computer::get_s() { return slide; }

int MatrixG_Computer::get_w() { return window; }

float MatrixG_Computer::sum_K() {
    float sum = 0;
    for (int i = 0; i < km_dim_1; i++) {
        for (int j = 0; j < km_dim_2; j++) {
            sum = sum + K(i,j);
        }
    }
    return sum;
}

string MatrixG_Computer::get_seq1(){
	return seq1;
}

string MatrixG_Computer::get_seq2(){
	return seq2;
}

#include "header.h"
// note: matrix G and F are constructed so that main colinear conservation signals are located along the main diagonal. i.e. in case of inversion, seq2 is inverted so that seq1 and seq2 are in same orientation.
// For outputing alingment coordinate, "rel_strand_loc" information is used. 

// constructor1: without external signal (e.g. gkmSVM)
Seq_Aligner::Seq_Aligner(Matrix* G, string rel_strand_loc, string ID_2align)
:
  km_dim_1(G->dims()[0]),
  km_dim_2(G->dims()[1]),
  dm_dim_1(km_dim_1 + 1),
  dm_dim_2(km_dim_2 + 1),
  G(G),
  K(km_dim_1, km_dim_2),
  DM(dm_dim_1, dm_dim_2, numeric_limits<float>::infinity()),
  rel_strand_loc(rel_strand_loc),
  type(1),
  ID_2align(ID_2align)

{

    DM(0,0) = 0;

    // z-transform

    mean = G->compute_mean();
    var = G->compute_var();
    for(int i = 0; i < km_dim_1; i++){
        for(int j = 0; j < km_dim_2; j++){
	    K(i,j) = ((*G)(i,j) - mean) / (sqrt(var) + 0.0001);
	}
    }


}

// constructor2: with external signal
Seq_Aligner::Seq_Aligner(Matrix* G, vector<float>* ann_vector_1, vector<float>* ann_vector_2, float wF, string rel_strand_loc, string ID_2align)
:
  km_dim_1(G->dims()[0]),
  km_dim_2(G->dims()[1]),
  dm_dim_1(km_dim_1 + 1),
  dm_dim_2(km_dim_2 + 1),
  G(G),
  aV1(ann_vector_1),
  aV2(ann_vector_2),	
  K(km_dim_1, km_dim_2),
  DM(dm_dim_1, dm_dim_2, numeric_limits<float>::infinity()),
  rel_strand_loc(rel_strand_loc),
  wF(wF),
  type(2),
  ID_2align(ID_2align)

{

    DM(0,0) = 0;

    float buffer = 0.01; 
    float ann_prod;
    for(int i = 0; i < km_dim_1; i++){
        for(int j = 0; j < km_dim_2; j++){
	    ann_prod = (*aV1)[i] * (*aV2)[j];
            K(i,j) = pow((*G)(i,j), 1-wF) * (pow(ann_prod, wF) + buffer) / (1 + buffer);
        }
    }

    // z-transform
    mean = K.compute_mean();
    var = K.compute_var();
    for(int i = 0; i < km_dim_1; i++){
        for(int j = 0; j < km_dim_2; j++){
            K(i,j) = (K(i,j) - mean) / (sqrt(var) + 0.0001);
        }
    }


}




vector<tuple<int, int>> Seq_Aligner::gen_dots(float indel){
    update_DM(indel);
    vector<tuple<int, int>> dots = backtrack(indel);
    return dots;
}


void Seq_Aligner::update_DM(float indel) {

    DM(0,0) = 0;
    for (int i = 1; i < dm_dim_1; i++) {
	DM(i,0) = i * (-indel); 
    }
    for (int j = 1; j < dm_dim_2; j++) {
	DM(0,j) = j * (-indel); 
    }
    // fill in dynamic matrix
    float cand1;
    float cand2;
    float cand3;
    float gkm_sim;
    std::vector<float> v;
    float max_elem;
    for (int i = 1; i < dm_dim_1; i++) {
        for (int j = 1; j < dm_dim_2; j++) {
            gkm_sim = K(i - 1, j - 1);
           cand1 = DM(i - 1, j - 1) + gkm_sim; 
            cand2 = DM(i - 1, j) - indel;
            cand3 = DM(i, j - 1) - indel;
            v = {cand1, cand2, cand3};
            max_elem = *(max_element(begin(v), end(v)));
	    DM(i,j) = max_elem;
        }
    }
}


// alignment using K_norm
vector<tuple<int, int>>
Seq_Aligner::backtrack(float indel) {

    // returns extension coordinates (match or sub) and its matrix values
    // takes both same_strand diff_strand matrix. If diff_strand matrix, coordinate will
    // be reverse mapped.
    // i.e. orientation of the corodinates will now be consistent with the genomic orientation. 

    // allowed numerical deviation
    float epsilon = 0.01;
    if ((rel_strand_loc != "same_strand") &&
        (rel_strand_loc != "diff_strand")) {
        cout << "Unrecognized type :" + rel_strand_loc << endl;
        exit(1);
    }


    vector<tuple<int, int>> dots;
    int i = dm_dim_1 - 1;
    int j = dm_dim_2 - 1;

    tuple<int, int> dot;

    int num_match = 0;
    int num_skip = 0;
    while (i > 0 || j > 0) {
        // Boolean values that encode which 'directions' are possible
        bool match = ((i > 0 && j > 0) &&
                      (fabs((DM(i - 1, j - 1) +
                             K(i - 1, j - 1)) -
                            DM(i, j)) < epsilon));
        bool indel1 = ((i > 0) &&
                       (fabs((DM(i - 1, j) - indel) - DM(i,j)) < epsilon));
        bool indel2 = ((j > 0) &&
                       (fabs((DM(i,j - 1) - indel) - DM(i,j)) < epsilon));

        if (match) {
            if (rel_strand_loc == "same_strand") {
                dot = make_tuple(i - 1, j - 1);
            } else if (rel_strand_loc == "diff_strand") {
                dot = make_tuple(i - 1, km_dim_2 - 1 - (j - 1));
            }
            dots.insert(dots.begin(), dot);
            --i;
            --j;
            num_match++;

        } else if (indel1) {
            --i;
            num_skip++;

        } else if (indel2) {
            --j;
            num_skip++;

        } else { // for debug.
            cout << "Unexpected event (debug needed)" << endl;
	    cout << ID_2align << endl;
	    (*G).save_matrix_tsv(ID_2align + ".debug.matrixG.tsv");
            K.save_matrix_tsv(ID_2align + ".debug.matrixK.tsv");
            DM.save_matrix_tsv(ID_2align + ".debug.matrixDM.tsv");

            (*G).save_matrix(ID_2align + ".debug.matrixG");
            K.save_matrix(ID_2align + ".debug.matrixK");
            DM.save_matrix(ID_2align + ".debug.matrixDM");


	    cout << "matrix mean: " << mean <<endl;
	    cout << "matrix var: " << var << endl;
            cout << DM(i,j) << endl;
	     
            cout << i << '\t' << j << endl;
            // cout<<DM[i-1][j-1]<<endl;
            cout << DM(i,j - 1) << endl;
            cout << DM(i,j - 1) - indel << endl;
            cout << fabs((DM(i,j - 1) - indel) - DM(i,j)) << endl;
            cout << (fabs((DM(i,j - 1) - indel) - DM(i,j)) < epsilon) << endl;
            exit(EXIT_FAILURE);
        }
    }
    return dots;
}



// Map DM index to genomic cooridnate (center of the window)
// coordinate = {coord1, coord2, Gval, aV1, aV2}
vector<tuple<int, int, string,  string, string>>
Seq_Aligner::dots_to_coords(
    vector<tuple<int, int>> &dots,
    int build_1_coord_start, int build_2_coord_start,
    int slide_width, int window_width, string rel_strand_loc) {
    
	
    vector<tuple<int, int, string, string,string>> coords;
    tuple<int, int, string, string, string> coord;
    int i; int j; string Gval; string aV_elem_1 = "."; string aV_elem_2 = ".";
    tuple<float,float> vals;
    for (auto &dot : dots) {
        i = get<0>(dot); j = get<1>(dot);
        if(rel_strand_loc == "same_strand"){
	    if(type == 1){
		Gval = to_string((*G)(i,j));
	    } else {
	        Gval = to_string((*G)(i,j));
		aV_elem_1 = to_string((*aV1)[i]);
		aV_elem_2 = to_string((*aV2)[j]);
	    }
	}else{ // Since G and ann vectors were computed by revcomping seq_2, in case of "diff_strand", their values need to be fetched through reversed coordinate. 
            if(type == 1){
                Gval = to_string((*G)(i,km_dim_2 - j - 1));
            } else {
                Gval = to_string((*G)(i,km_dim_2 - j - 1));
		aV_elem_1 = to_string((*aV1)[i]);
                aV_elem_2 = to_string((*aV2)[km_dim_2 - j - 1]);
            }

        }
        coord = make_tuple(build_1_coord_start + (i * slide_width) +
                               window_width / 2,
                           build_2_coord_start + (j * slide_width) +
                               window_width / 2,
                           Gval, aV_elem_1, aV_elem_2);
        coords.push_back(coord);
    }
    return coords;
}



#include "header.h"

vector<float> track_shared_gkmer_contribution(string which_seq, string seq1, string seq2, int lmer_length, Matrix& G, bool);
void save_cons_file(string ofname, string seq, vector<float> sc, string description);
vector<float> avg_deltaSVM(string& seq, unordered_map<string, float>& kmer_weights);
vector<char> ATGC = {'A', 'T', 'G', 'C'};

int main(int argc, char *argv[]) {
    int lmer_length = 11;
    int non_gap = 7;
    bool colinear = false; // visualize colinearly conserved gapped kmers only. (i.e. TFBS in the same order in human and mouse enhancers)
    string gdir = "NULL";
    string rmfile_name = "NULL";
    string ifname;
    string model_list_fname = "NULL";
    string ofile_directory = "";
    bool output_G_matrix = false;
    string of_prefix = "NULL";    
    char opt;
    while ((opt = getopt(argc, argv, ":l:k:W:g:d:n:o:cGh")) != -1) {
        switch (opt) {
        case 'l':
            lmer_length = atoi(optarg);
            break;
        case 'k':
            non_gap = atoi(optarg);
            break;
	case 'c':
	    colinear = true;
	    break;
        case 'G':
            output_G_matrix = true;
            break;
	case 'd':
	    gdir = string(optarg);
	    break;
        case 'g':
            rmfile_name = string(optarg);
            break;

	case 'W':
	    model_list_fname = string(optarg);
	    break;
        case 'h':
            cout << "description" << endl;
            exit(0);
	case 'n':
	    of_prefix = string(optarg);
	    break; 
        case 'o':
            ofile_directory = string(optarg);
            if (*(prev(ofile_directory.end())) != '/') {
                ofile_directory = ofile_directory + '/';
            }
            break;

        case ':':
            printf("Missing argument for %c\n", optopt);
            exit(1);

        case '?':
            cout << "Unknown option: " << char(optopt) << endl;
            exit(1);
        }
    }

    if (optind + 1 != argc) {
        cout << "One positional argument is required: input file name"
                 << endl;
            exit(1);
    } else {
            ifname = argv[optind];
    }

    if (gdir == "NULL"){
	    cout << "genome directory (containing directories for both query and target genome builds)" << endl;
	    exit(1);
    }
 


    cout << "\n-- Parameters --" << endl;
    cout << "l-mer length: " << lmer_length << " (default: 11)" << endl;
    cout << "number of informative base pairs: " << non_gap
         << " (default: 7)" << endl;

    if(colinear){cout << "colinear common gapped kmer visualization" << endl;}
    else{cout << "visualizing all common gapped kmers" << endl;};


    // load weight files, if provided 
    vector<tuple<string,unordered_map<string, float>>> model_list;
    string model_id; string model_fn;
    unordered_map<string, float> kmer_weights;
    if(model_list_fname != "NULL" ){
        check_file(model_list_fname);
        ifstream ml_file(model_list_fname);
        string line;
        while (getline(ml_file, line)) {
            istringstream ss(line);
            ss >>  model_id >> model_fn;
            check_file(model_fn);
            load_weights(kmer_weights, model_fn);
            model_list.push_back(make_tuple(model_id, kmer_weights));
        }
    }

    // load maskers, if provided
    unordered_map<string, float> masker_weights_1;
    unordered_map<string, float> masker_weights_2;
    float mthreshold_1;
    float mthreshold_2;
    if(rmfile_name != "NULL"){
	ifstream rm_file (rmfile_name);
        string rmodel_fname1;
        string rmodel_fname2;
        getline(rm_file, rmodel_fname1);
        getline(rm_file, rmodel_fname2);

        mthreshold_1 = load_weights_threshold(masker_weights_1, rmodel_fname1);
        mthreshold_2 = load_weights_threshold(masker_weights_2, rmodel_fname2);
    }

    check_file(ifname);
    ifstream ifile(ifname);
    string line; 
            //mm10    chr2    152437520       152437820       -->     hg38    chr20   279005  279304    qDnase:150_mDnase:120_gkmsim_0.2_mgkmSVM_0.98_reg_152.3

    string build1; string chr1; int start1; int end1;
    string build2; string chr2; int start2; int end2;
    string cons_info;
    string tmp;
    int index = 0;
     while (getline(ifile, line)) {
         istringstream ss(line);
         ss >> build1 >> chr1 >> start1 >> end1 >>  tmp
                     >> build2 >> chr2 >> start2 >> end2 >> cons_info;

         if(chr2 == "not-mapped"){
             continue;
         }
         string build1_fname = gdir + "/" + build1 + "/" + chr1 + ".fa";
         string build2_fname = gdir + "/" + build2 + "/" + chr2 + ".fa";
         string seq_1 = read_fa(build1_fname, start1, end1);
         string seq_2 = read_fa(build2_fname, start2, end2);
         seq_1 = preprocess_seq(seq_1);
         seq_2 = preprocess_seq(seq_2);
	 string mseq_1 = seq_1;
	 string mseq_2 = seq_2;
	 if(rmfile_name != "NULL"){
                auto masking_pair_1 = mask_seq(seq_1, masker_weights_1, mthreshold_1);
                auto masking_pair_2 = mask_seq(seq_2, masker_weights_2, mthreshold_2);
                mseq_1 = masking_pair_1.first;
                mseq_2 = masking_pair_2.first;
	 }
	 // first test if the two sequences are in the same or different strands by computing seq similairty in both directions. 
	 MatrixG_Computer kc_tmp1(lmer_length, non_gap, 1,  seq_1.length(),
			 seq_1, seq_2, "same_strand", 1);
	 Matrix& G1_tmp = kc_tmp1.compute_full_matrix(); 
	
	 MatrixG_Computer kc_tmp2(lmer_length, non_gap, 1,  seq_1.length(),
                               seq_1, revcomp(seq_2), "same_strand", 1);
         Matrix& G2_tmp = kc_tmp2.compute_full_matrix();
   
	 if(G1_tmp(0,0) < G2_tmp(0,0)){
		seq_2 = revcomp(seq_2);
 	 	mseq_2 = revcomp(mseq_2);
	 }


	 // now compute matrix to track where shared gapped kmers come from
	 MatrixG_Computer kc(lmer_length, non_gap, 1, lmer_length, mseq_1, mseq_2, "same_strand", 1);
	 Matrix& G = kc.compute_full_matrix();


	 if(colinear){  
		// align within enahcner pairs, and set matrix elements that are included in the path to 0
		Seq_Aligner sa(&G, "same_strand", "");
                vector<tuple<int, int>> aligned_dots = sa.gen_dots(0);
		auto dims = G.dims();
		Matrix G_bools = Matrix(dims[0], dims[1],0);
		for(auto dot : aligned_dots){
			G_bools(get<0>(dot), get<1>(dot)) = 1;
		}

		for(unsigned int i = 0; i < dims[0]; i++){
		    for(unsigned int j = 0; j < dims[1]; j++){
	                if(G_bools(i,j) == 0){
				G(i,j) = 0;
			}
		    }
		}

	 }

	 if(output_G_matrix){
	     G.save_matrix(of_prefix + "_" +to_string(index) + ".matrixG");
	
	 
	 }

	// diff normalization is applied by whether it's colinear or not 
         vector<float> seq1_cons_sc = track_shared_gkmer_contribution("1", mseq_1, mseq_2, lmer_length, G, colinear);
         vector<float> seq2_cons_sc = track_shared_gkmer_contribution("2", mseq_1, mseq_2, lmer_length, G, colinear);

	 if(of_prefix == "NULL"){
             of_prefix = ifname;
	 }
         string ofname_q = ofile_directory +  of_prefix + "_q" + to_string(index) + ".cons_sc";
         string ofname_t = ofile_directory + of_prefix + "_t" + to_string(index) + ".cons_sc";
         save_cons_file(ofname_q, seq_1, seq1_cons_sc, line);
         save_cons_file(ofname_t, seq_2, seq2_cons_sc, line);

         string id_q = build1 + "/" +  chr1 + ":" + to_string(start1) + "-" + to_string(end1) + "/";
         string id_t = build2 + "/" +  chr2 + ":" + to_string(start2) + "-" + to_string(end2) + "/";

         string ofname = ofile_directory + of_prefix + "_" + to_string(index) + ".png";

         string command;
         // assumes python script is in the executable's directory.
         if(model_list_fname == "NULL"){
             command = "python3 " + dirname(getexepath()) + "/" +  "logo_shared_gkmer.py "
                                                   + ofname_q + " " + ofname_t + " " + id_q + " " + id_t + " " + cons_info
                                                   + " " + ofname;
         } else { // call a different python script after computing scores.
             string id;
             vector<float> bp_scores;
             vector< tuple<string, vector<float>> > score_matrix_q;
             for(auto& model : model_list){
                 id = get<0>(model);
                 bp_scores = avg_deltaSVM(seq_1, get<1>(model));
                 score_matrix_q.push_back(make_tuple(id, bp_scores));
             }

             vector< tuple<string, vector<float>> > score_matrix_t;
             for(auto& model : model_list){
                 id = get<0>(model);
                 bp_scores = avg_deltaSVM(seq_2, get<1>(model));
                 score_matrix_t.push_back(make_tuple(id, bp_scores));
             }

	     string gkmsvm_weight_ofile_q = ofile_directory +  ifname + "_q" + to_string(index) + ".avg_dSVM";
             string gkmsvm_weight_ofile_t = ofile_directory +  ifname + "_t" + to_string(index) + ".avg_dSVM";

	     // output gkmsvm score on query sequence
             ofstream gkmsvm_ofile_q(gkmsvm_weight_ofile_q);
             gkmsvm_ofile_q << "gkmsvm_models" << '\t';
             for(auto model : score_matrix_q){
                 gkmsvm_ofile_q << get<0>(model) << '\t';
             }
             gkmsvm_ofile_q << endl;

             for(unsigned int i = 0; i < seq_1.size(); i++){
                 gkmsvm_ofile_q << seq_1[i] << '\t';
                 for(auto model : score_matrix_q){
                     gkmsvm_ofile_q << get<1>(model)[i] << '\t';
                 }
                 gkmsvm_ofile_q << endl;
             }
             gkmsvm_ofile_q.close();
	     


	     ofstream gkmsvm_ofile_t(gkmsvm_weight_ofile_t);
             gkmsvm_ofile_t << "gkmsvm_models" << '\t';
             for(auto model : score_matrix_t){
                 gkmsvm_ofile_t << get<0>(model) << '\t';
             }
             gkmsvm_ofile_t << endl;

             for(unsigned int i = 0; i < seq_2.size(); i++){
                 gkmsvm_ofile_t << seq_2[i] << '\t';
                 for(auto model : score_matrix_t){
                     gkmsvm_ofile_t << get<1>(model)[i] << '\t';
                 }
                 gkmsvm_ofile_t << endl;
             }
             gkmsvm_ofile_t.close();

             command = "python3 " + dirname(getexepath()) + "/" +  "logo_shared_gkmer_and_deltaSVM.py "
                                                   + ofname_q + " " + gkmsvm_weight_ofile_q + " " + id_q + " "
                                                   + ofname_t + " " + gkmsvm_weight_ofile_t + " " + id_t + " " + cons_info
                                                   + " " + ofname;

         }
             system(command.c_str());
             cout<<"command: " << command<<endl;
             index++;

    }

    

    
    return 0;
}



vector<float> track_shared_gkmer_contribution(string which_seq, string seq1, string seq2, int l,  Matrix& G, bool colinear){
    vector<float> sums;
    vector<size_t> dims = G.dims();
    int seqL;
    int w;
    if(which_seq == "1"){
        seqL = seq1.size();
	w = seq2.size();
        for(int i = 0; i < (int)dims[0]; i++){
            float sum = 0;
            for(int j = 0; j < (int)dims[1]; j++){
                sum = sum + G(i,j);
            }
            sums.push_back(sum);
        }

    }else if(which_seq == "2"){ // col sum
        seqL = seq2.size();
	w = seq1.size();
        for(int j = 0; j < (int)dims[1]; j++){
            float sum = 0;
            for(int i = 0; i < (int)dims[0]; i++){
                sum = sum + G(i,j);
            }
            sums.push_back(sum);
        }
    }else{
        cout<<"Unrecognized input: " << which_seq << endl;
        exit(1);
    }

    vector<float> vo;
    int lower_bound; int upper_bound; float  val;
    for(int i = 0; i<=seqL-1; i++){
        lower_bound = min(max(0, i-l+1), seqL-l);
        upper_bound = max(min(seqL-l, i), 0);
        val = 0;
        for(int j = lower_bound; j<=upper_bound; j++){
            val = val + sums[j];
        }
//normalize to 1 
	if(colinear){
        	vo.push_back(val/l);
	}else{
		vo.push_back(val/(l*(w-l+1)));
	}

    }
    return vo;
}


void save_cons_file(string ofname, string seq, vector<float> sc, string description){
    ofstream ofile(ofname);
    ofile << "# " << endl;
    ofile << "# " << description << endl;
    ofile << "# " << endl;

    ofile << "pos" << '\t' << 'A' << '\t' << 'C' << '\t'<< 'G' << '\t' <<'T' << endl;

    for(unsigned int i = 0; i<seq.size(); i++){
        vector<float> orow = {0,0,0,0};
        if(seq[i] == 'A'){
            orow[0] = sc[i];
        }else if(seq[i] == 'C'){
            orow[1] = sc[i];
        }else if(seq[i] == 'G'){
            orow[2] = sc[i];
        }else if(seq[i] == 'T'){
            orow[3] = sc[i];
        }else{
            cout<<"Unexpected character: " << seq[i] <<endl;
        }

        ofile << i << '\t' << orow[0] << '\t' << orow[1] << '\t' << orow[2] << '\t' << orow[3] <<  endl;
    }
    ofile.close();
}

vector<float> avg_deltaSVM(string& seq, unordered_map<string, float>& kmer_weights) {
    transform(seq.begin(), seq.end(), seq.begin(), ::toupper);
    vector<float> bp_scores;
    int k = ((*(kmer_weights.begin())).first).length();
    char original_nuc; float init_sc; float sum;
    for (unsigned int pos = 0; pos < seq.length(); pos++) {
        original_nuc = seq[pos];
        init_sc = score_bp(seq, pos, kmer_weights, k);
        sum = 0;
        for(char SNV : ATGC){
            if(SNV != original_nuc){
                seq[pos] = SNV;
                sum = sum + (score_bp(seq, pos, kmer_weights, k) - init_sc);
            }
        }
        seq[pos] = original_nuc;
        bp_scores.push_back(sum/((ATGC.size()-1)));
    }
    return bp_scores;
}

